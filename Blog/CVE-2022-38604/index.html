<!DOCTYPE html>

<!-- https://www.amp-what.com/unicode/search/icon -->
<!-- Serif - Times - Times New Roman (default font) -->
<!-- <a href="" target="_blank" rel="noopener noreferrer">linkText</a> (open the link in a new tab and avoid tabnabbing) -->
<!-- <a name="anchorName"></a> | <a href="#anchorName">link name</a> (anchor) -->

<html lang="en">

	<head>
		
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="Wacom Driver Arbitrary File Deletion Vulnerability">
		<meta name="keywords" content="CVE-2022-38604, AFD, Arbitrary File Deletion, From Arbitrary File Deletion to Local Privilege Escalation, AFD2LPE, From Arbitrary File Deletion to Windows Denial of Service, AFD2WDOS, AFD2DOS, Vulnerability, Wacom, Wacom Driver, Wacom Driver 6.3.46-1, Driver, Bug, Exploit, Security, Cybersecurity, 0-day, zero-day, Graphics tablet, Logical vulnerability, Process Monitor, dynamic analysis, Write-up, POC, Proof Of Concept, CNA-LR, Disclosure, Responsible disclosure, Luca Barile, Fix, Patch, Remove.exe, Impersonation, WacomDesktopCenter, symbolic link, mount point, Link Following">
		<meta name="author" content="Luca Barile">
		
		<link rel="stylesheet" href="../postsStyle.css">
		
		<title>CVE-2022-38604</title>
    
	</head>

	<body bgcolor="black" text="DarkGray" link="lightblue" alink="gold" vlink="DarkRed">
	
		<h1>Wacom Driver Arbitrary File Deletion Vulnerability</h1>
		<h2 align="center" style="color:white">CVE-2022-38604 (0-day)</h2>
		
		<div>
			<p>
				<h2 align="center">Table of Contents &#128220;</h2>
				<h3>
					<table border="1" align="center">
						<tr>
							<td>
								<ol>
									<li><a href="#par1">Premise</a></li>
									<li><a href="#par2">How did I discover the vulnerability?</a></li>
									<li><a href="#par3">Analyzing uninstaller operations</a></li>
									<li><a href="#par4">An Arbitrary File Deletion primitive</a></li>
									<li><a href="#par5">The Exploit</a></li>
									<li><a href="#par6">POC</a></li>
									<li><a href="#par7">From Arbitrary File Deletion to Local Privilege Escalation</a></li>
									<li><a href="#par8">From Arbitrary File Deletion to Windows Denial of Service</a></li>
									<li><a href="#par9">Something more on CatRoot folder</a></li>
									<li><a href="#par10">How to fix the vulnerability</a></li>
									<li><a href="#par11">Vulnerability disclosure timeline</a></li>
									<li><a href="#par12">Final considerations</a></li>
								</ol>
							</td>
						</tr>
					</table>
				</h3>	
			</p>
			
			<p>
				<a name="par1"></a>
				<h2>Premise</h2>
				<h3>
					This article describes a vulnerability affecting Wacom Driver <a href="https://github.com/LucaBarile/ZDI-CAN-16857/tree/main/WacomTablet_6.3.46-1" target="_blank" rel="noopener noreferrer">6.3.46-1</a> and <a href="https://github.com/LucaBarile/ZDI-CAN-16318/tree/main/WacomTablet_6.3.45-1" target="_blank" rel="noopener noreferrer">6.3.45-1</a> for Windows (it probably affects older versions as well but I haven't tested them) and a way by which this vulnerability can be exploited for an arbitrary file deletion.<br>
					I suggest to read <a href="../ZDI-CAN-16857/index.html" target="_blank" rel="noopener noreferrer">this</a> article to better understand some points of what youâ€™re going to read.
				</h3>
			</p>
			
			<p>
				<a name="par2"></a>
				<h2>How did I discover the vulnerability?</h2>
				<h3>
					Reading some blogs of other vulnerability researchers I found that sometimes, during the installation of a program, if the folders in which the program installs files (that should only be controlled by the system administrator) already exist, files are installed anyway and the access permissions to the folders aren't changed, allowing an unprivileged user to have full control on them (he just has to create these folders before the program gets installed).<br>
					This situation can lead to security issues (as in <a href="https://vuls.cert.org/confluence/display/Wiki/2021/06/21/Finding+Privilege+Escalation+Vulnerabilities+in+Windows+using+Process+Monitor#FindingPrivilegeEscalationVulnerabilitiesinWindowsusingProcessMonitor-Allowinguser-specifiedinstallationdirectorieswithoutsettingsACLs" target="_blank" rel="noopener noreferrer">this</a> case) and, since I've already found other vulnerabilities (<a href="../ZDI-CAN-16318/lpe/index.html" target="_blank" rel="noopener noreferrer">this</a> and <a href="../ZDI-CAN-16857/index.html" target="_blank" rel="noopener noreferrer">this</a>) affecting Wacom Driver for Windows, I decided to check if it also is affected by this kind of vulnerability.<br>
					Unfortunately (for us) the installer doesn't allow the user to choose the installation folder, the created folders that the unprivileged  user can control are used by processes that impersonate the current user and the remaining folders have a secure <a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/dacls-and-aces" target="_blank" rel="noopener noreferrer">DACL</a>.<br>
					At this point, since the installer didn't get me anywhere, I tried to analyze the uninstaller and, in this case, I was luckier &#128579;
				</h3>
			</p>
			
			<p>
				<a name="par3"></a>
				<h2>Analyzing uninstaller operations &#128269;</h2>
				<h3>
					If the system administrator decides to uninstall Wacom Driver (administrator privileges are required), the uninstaller triggers <code>%ProgramFiles%\Tablet\Wacom\32\Remove.exe</code> which runs under the context of <a href="https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account" target="_blank" rel="noopener noreferrer">SYSTEM</a>.<br>
					Once started, <code>Remove.exe</code>, as the name suggests, begins to remove all the files created during the installation process and by the user while using the Wacom device. It also removes files located in folders over which the unprivileged user has full control by impersonating the current user but, for some reason, a small number of files are deleted without impersonating the user, even if they're located in folders over which the unprivileged user has full control &#129300;<br>
					I used <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon" target="_blank" rel="noopener noreferrer">Process Monitor</a> to identify this small number of files; they're three and <code>Remove.exe</code> tries to delete them from different folders:
					
					
					<ol>
						<li>
							Wacom_Tablet.dat
							<ul>
								<li><code>%UserProfile%\Application Data\WTablet\Wacom_Tablet.dat</code></li>
								<li><code>%UserProfile%\AppData\Roaming\WTablet\Wacom_Tablet.dat</code></li>
								<li><code>%UserProfile%\Roaming\WTablet\Wacom_Tablet.dat</code></li>
								<li><code>%UserProfile%\WTablet\Wacom_Tablet.dat</code></li>
							</ul>
						</li>
						
						<li>
							Tablet.dat
							<ul>
								<li><code>%UserProfile%\Application Data\WTablet\Tablet.dat</code></li>
								<li><code>%UserProfile%\AppData\Roaming\WTablet\Tablet.dat</code></li>
								<li><code>%UserProfile%\Roaming\WTablet\Tablet.dat</code></li>
								<li><code>%UserProfile%\WTablet\Tablet.dat</code></li>
							</ul>
						</li>
						
						<li>
							WacomTouch.xml
							<ul>
								<li><code>%UserProfile%\Application Data\WTablet\WacomTouch.xml</code></li>
								<li><code>%UserProfile%\AppData\Roaming\WTablet\WacomTouch.xml</code></li>
								<li><code>%UserProfile%\Roaming\WTablet\WacomTouch.xml</code></li>
								<li><code>%UserProfile%\WTablet\WacomTouch.xml</code></li>
							</ul>
						</li>		
					</ol>
					
					It's interesting to note that some folders do not exist (they've never been created by the installer), but <code>Remove.exe</code> tries to delete some files located in them anyway.<br>
					One of these folders, for example, is <code>%UserProfile%\WTablet</code>.<br>
					I assume that in some Wacom Driver versions prior to 6.3.46-1, these folders were used. Later, they've not been used anymore, and the developers forgot to remove them from the list of folders in which <code>Remove.exe</code> must remove some files.
					
				</h3>
			</p>
			
			<p>
				<a name="par4"></a>
				<h2>An Arbitrary File Deletion primitive &#128465;&#65039;</h2>
				<h3>
					Probably, if you have read these three articles (<a href="../ZDI-CAN-16857/index.html" target="_blank" rel="noopener noreferrer">1</a>, <a href="../ZDI-CAN-16318/arb_r/index.html" target="_blank" rel="noopener noreferrer">2</a> and <a href="../ZDI-CAN-16318/arb_rw/index.html" target="_blank" rel="noopener noreferrer">3</a>), by now you will have understood that when the situation just described occur, the <a href="https://cwe.mitre.org/data/definitions/59.html" target="_blank" rel="noopener noreferrer">link following attack</a> is the first thing that comes to mind and, even in this case, it can be applied in a similar way to what has been done <a href="../ZDI-CAN-16318/arb_rw/index.html#par4" target="_blank" rel="noopener noreferrer">here</a> and <a href="../ZDI-CAN-16318/arb_rw/index.html#par6" target="_blank" rel="noopener noreferrer">here</a>.<br>
					Our situation is slightly different from the linked ones because instead of redirecting a file writing, we redirect a file deletion,  therefore we'll get an Arbitrary File Deletion primitive.<br>
					I decided to create the <code>%UserProfile%\WTablet</code> <a href="https://en.wikipedia.org/wiki/NTFS_volume_mount_point" target="_blank" rel="noopener noreferrer">NTFS volume mount point</a> to <a href="https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html" target="_blank" rel="noopener noreferrer">\RPC Control</a> (I chose this folder because it doesn't exist, so I don't even have to worry about deleting it and, at the same time, it avoids causing any problems to processes that might try to access the files it contains).<br>
					Then I created a <a href="https://en.wikipedia.org/wiki/Symbolic_link" target="_blank" rel="noopener noreferrer">Symbolic link</a> from <code>\RPC Control\Tablet.dat</code> to <code>%windir%\win.ini</code>.<br>
					Now the workflow is quite simple: when the system administrator decides to uninstall Wacom Driver, <code>Remove.exe</code> is triggered and, among the various operations it carries out, it will try to delete <code>%UserProfile%\WTablet\Tablet.dat</code>.<br>
					Since <code>%UserProfile%\WTablet</code> is a mount point to <code>\RPC Control</code>, <code>Remove.exe</code> will be redirected and will try to delete <code>\RPC Control\Tablet.dat</code>.<br>
					Since <code>\RPC Control\Tablet.dat</code> is a symbolic link to <code>%windir%\win.ini</code>, <code>Remove.exe</code> will be redirected again, and will try to delete <code>%windir%\win.ini</code> (and it will succeed because it's running under the context of <code>SYSTEM</code>).<br>
					Obviously, in this case, I chose to delete <code>%windir%\win.ini</code> as Proof of Concept, since <code>win.ini</code> is a file that the unprivileged user cannot delete, but we can choose to delete the file we prefer.
				</h3>
			</p>
		
			<p>
				<a name="par5"></a>
				<h2>The Exploit &#9760;&#65039;</h2>
				<h3>
					The exploit that I wrote is based on the aforementioned workflow and performs the following steps:
					
					<ol>
					
						<li>
							Ask the user which file he wants to delete (let's suppose <code>%windir%\win.ini</code>).
						</li>
						
						<li>
							Create the <code>%UserProfile%\WTablet</code> mount point to <code>\RPC Control</code>.
						</li>
						
						<li>
							Create the <code>\RPC Control\Tablet.dat</code> symbolic link to <code><code>%windir%\win.ini</code></code>.
						</li>
						
						<li>
							Wait for the system administrator to uninstall Wacom Driver.
						</li>
						
						<li>
							When the system administrator decides to uninstall Wacom Driver, <code>Remove.exe</code> is triggered (and runs under the context of <code>SYSTEM</code>).
						</li>
						
						<li>
							<code>Remove.exe</code> will try to delete <code>%UserProfile%\WTablet\Tablet.dat</code>.
						</li>
						
						<li>
							Since <code>%UserProfile%\WTablet</code> is a mount point to <code>\RPC Control</code>, <code>Remove.exe</code> will be redirected and will try to delete <code>\RPC Control\Tablet.dat</code>.
						</li>
						
						<li>
							Since <code>\RPC Control\Tablet.dat</code> is a symbolic link to <code>%windir%\win.ini</code>, <code>Remove.exe</code> will be redirected again, and will try to delete <code>%windir%\win.ini</code>.
						</li>
						
						<li>
							 <code>Remove.exe</code> deletes <code>%windir%\win.ini</code>.
						</li>
					
					</ol>
					
					<a href="https://github.com/LucaBarile/CVE-2022-38604/tree/main/Exploits/AFD/Exploit.bat" target="_blank" rel="noopener noreferrer">Here</a> you can find my exploit.<br>
					<br>
					<code>CreateMountPoint.exe</code> and <code>CreateSymlink.exe</code> are programs developed by <a href="https://twitter.com/tiraniddo" target="_blank" rel="noopener noreferrer">James Forshaw</a> and are downloadable from his <a href="https://github.com/googleprojectzero/symboliclink-testing-tools" target="_blank" rel="noopener noreferrer">symboliclink-testing-tools</a> repository, respectively <a href="https://github.com/googleprojectzero/symboliclink-testing-tools/tree/main/CreateMountPoint" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://github.com/googleprojectzero/symboliclink-testing-tools/tree/main/CreateSymlink" target="_blank" rel="noopener noreferrer">here</a>.
					
				</h3>
			</p>
			
			<p>
				<a name="par6"></a>
				<h2>POC &#127910;</h2>
				<h3>
					I've tested the exploit only for Wacom Driver 6.3.46-1 but, most likely, it also works for the previous versions (and I hope not on the future ones &#128580;). 
				</h3>
			</p>
			
		</div>
			
		<img src="media/POC_AFD.gif" alt="" title="Exploitation Proof Of Concept">
		
		<div>
			<p>
				<a name="par7"></a>
				<h2>From Arbitrary File Deletion to Local Privilege Escalation &#128293;</h2>
				<h3>
					When youâ€™ve found an Arbitrary File Deletion you'd probably like to use it to achieve something more useful, like a Local Privilege Escalation, but you don't know how to do it.<br>
					I didnâ€™t know how to do it either, but <a href="https://twitter.com/klinix5" target="_blank" rel="noopener noreferrer">Abdelhamid Naceri</a> (aka klinix5 or halov) did &#128583;<br>
					Abdelhamid has found a brilliant technique to achieve this result, and allowed <a href="https://twitter.com/hexkitchen" target="_blank" rel="noopener noreferrer">Simon Zuckerbraun</a> (aka HexKitchen) to publish <a href="https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks" target="_blank" rel="noopener noreferrer">this</a> wonderful article (read it!).<br>
					In a nutshell, Abdelhamid teaches us the following things:<br>
					
					<ol>
						<li>
							The <a href="https://docs.microsoft.com/en-us/windows/win32/msi/windows-installer-portal" target="_blank" rel="noopener noreferrer">Windows Installer service</a> (which is responsible for performing installations of applications) creates the <code>C:\Config.Msi</code> folder and populates it with rollback information (rollback files (<code>.rbf</code>) and scripts (<code>.rbs</code>)), in case it should restore them if the installation, for some reason, cannot be completed.
						</li>
						
						<li>
							If an attacker has an Arbitrary Folder Delete vulnerability he can uses it to remove <code>C:\Config.Msi</code> immediately after Windows Installer creates it, and can recreates it with a weak DACL (an unprivileged user is allowed to create folders at <code>C:\</code>).<br>
							At this point, once Windows Installer creates its rollback scripts within <code>C:\Config.Msi</code>, the unprivileged user can replace one of them with a malicious <code>.rbs</code> script that drops a malicious DLL once triggered (upon rollback).
						</li>
						
						<li>
							If the malicious <code>.rbs</code> script drops a malicious <code>HID.DLL</code> into <code>C:\Program Files\Common Files\microsoft shared\ink</code> folder, the unprivileged user could get a <code>SYSTEM</code> command prompt by starting <code>C:\Windows\System32\osk.exe</code> (the On-Screen Keyboard) and then switching to the <a href="https://security.stackexchange.com/questions/3759/how-does-the-windows-secure-desktop-mode-work" target="_blank" rel="noopener noreferrer">Secure Desktop</a> (for example by pressing Ctrl+Alt+Canc).
						</li>
						
						<li>
							In the <a href="https://en.wikipedia.org/wiki/NTFS" target="_blank" rel="noopener noreferrer">NTFS</a>, the metadata (index data) associated with a folder is stored in an alternate data stream on that folder.<br>
							For example, if the folder is named <code>C:\MyFolder</code>, then the its index data is in the data stream <code>C:\MyFolder::$INDEX_ALLOCATION</code> (<a href="http://inform.pucp.edu.pe/~inf232/Ntfs/ntfs_doc_v0.5/attributes/index_allocation.html" target="_blank" rel="noopener noreferrer">here</a> you can find more information). 
						</li>
						
						<li>
							Deleting the folder data stream <code>C:\MyFolder::$INDEX_ALLOCATION</code> effectively deletes <code>C:\MyFolder</code> from the <a href="https://en.wikipedia.org/wiki/File_system" target="_blank" rel="noopener noreferrer">file system</a>.<br>
							<u>REMEMBER</u>: We can delete the folder data stream (eg <code>C:\MyFolder::$INDEX_ALLOCATION</code>) only if the associate folder (eg <code>C:\MyFolder</code>) is empty!
						</li>
						
						<li>
							A data stream name (eg <code>C:\MyFolder::$INDEX_ALLOCATION</code>), can be passed to APIs that expect the name of a file, as <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilea" target="_blank" rel="noopener noreferrer">DeleteFileA</a> or <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilew" target="_blank" rel="noopener noreferrer">DeleteFileW</a>.<br>
							If a privileged process simply calls <code>DeleteFileA</code> or <code>DeleteFileW</code> on a data stream, <u>without performing other associated actions</u> (such as checking the attributes of the specified file), the data stream will be deleted.
						</li>
					</ol>
					
					All this things tells us that if we're able to trick a privileged process to delete an arbitrary file (as we did <a href="#par5">here</a>), and the process uses the <code>DeleteFileA</code> or <code>DeleteFileW</code> functions without performing other associated actions (just like <code>Remove.exe</code> does), then we can use the aforementioned Abdelhamid exploit technique to get a <code>SYSTEM</code> command prompt, gaining our Local Privilege Escalation.<br>
					<u>However</u> we've to consider that this technique is not reliable at 100% because it has to win a <a href="https://techterms.com/definition/race_condition" target="_blank" rel="noopener noreferrer">race condition</a>: when Windows Installer creates the <code>C:\Config.Msi</code> folder, we've to delete and recreate it before Windows Installer writes its rollback files and scripts, otherwise we will no longer be able to delete it (because it would no longer be empty).<br>
					To win the race we can use an <a href="https://lucabarile.github.io/Blog/toctou/index.html" target="_blank" rel="noopener noreferrer">Opportunistic Lock</a> (OpLock), and polling continuously for the existence of <code>C:\Config.Msi</code>, but there's still a chance in which Windows Installer could win the race writing its rollback files and scripts in the folder before we delete and recreate it, so this technique can fail sometimes (to increase the chances of winning the race, it's recommended a system with a minimum of 4 processor cores).<br>
					<br>
					Abdelhamid implemented this technique in an exploit, which awaits the attempt of a privileged process to delete the <code>C:\Config.Msi</code> folder (triggerable using our Arbitrary File Deletion primitive (or with an Arbitrary Folder Deletion)), and then performs the aforementioned steps to drop the malicious <code>HID.DLL</code> into <code>C:\Program Files\Common Files\microsoft shared\ink</code> folder, which allow us to gain our Local Privilege Escalation.<br>
					The source code of the exploit was published (with minor modifications) <a href="https://github.com/thezdi/PoC/blob/master/FilesystemEoPs/FolderOrFileDeleteToSystem/FolderOrFileDeleteToSystem.cpp" target="_blank" rel="noopener noreferrer">here</a> and, for convenience, I copied <a href="https://github.com/thezdi/PoC/blob/master/FilesystemEoPs" target="_blank" rel="noopener noreferrer">the original</a> repository <a href="https://github.com/LucaBarile/CVE-2022-38604/tree/main/FilesystemEoPs" target="_blank" rel="noopener noreferrer">here</a>, with the addition of the <a href="https://github.com/LucaBarile/CVE-2022-38604/tree/main/FilesystemEoPs/x64/Release" target="_blank" rel="noopener noreferrer">x64 compiled projects</a>.<br>
					<a href="https://github.com/LucaBarile/CVE-2022-38604/raw/main/FilesystemEoPs/x64/Release/FolderOrFileDeleteToSystem.exe" target="_blank" rel="noopener noreferrer">Here</a> you can download the exploit compiled for a 64-bit system.<br>
					<br>
					And if we can only delete <u>the contents</u> of an arbitrary folder (Arbitrary Folder Contents Delete primitive), can we gain an Arbitrary Folder Deletion primitive to use for a Local Privilege Escalation with the exploit technique previously discussed?<br>
					Yes, we can! Using the Abdelhamid exploit techniques (described in the "From Folder Contents Delete to SYSTEM EoP" paragraph of <a href="https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks" target="_blank" rel="noopener noreferrer">Simon's article</a>).<br>
					We must first gain an Arbitrary Folder Deletion primitive using our Arbitrary Folder Contents Delete primitive (<a href="https://github.com/LucaBarile/CVE-2022-38604/raw/main/FilesystemEoPs/x64/Release/FolderContentsDeleteToFolderDelete.exe" target="_blank" rel="noopener noreferrer">here</a> you can find the exploit that allows us to do this (compiled for a 64-bit system) and <a href="https://github.com/LucaBarile/CVE-2022-38604/blob/main/FilesystemEoPs/FolderContentsDeleteToFolderDelete/FolderContentsDeleteToFolderDelete.cpp" target="_blank" rel="noopener noreferrer">here</a> its source code) and then we've to use the Arbitrary Folder Deletion primitive with the exploit  previously discussed (we're chaining both the exploits).<br>
					<br>
					So, returning to Wacom Driver, how can we use our Arbitrary File Deletion primitive to gain a Local Privilege Escalation?<br>
					We just need to run the Abdelhamid exploit (<a href="https://github.com/LucaBarile/CVE-2022-38604/raw/main/FilesystemEoPs/x64/Release/FolderOrFileDeleteToSystem.exe" target="_blank" rel="noopener noreferrer">FolderOrFileDeleteToSystem.exe</a>) before using our Arbitrary File Deletion primitive and, instead of letting the user choose which file to delete, we must use the Arbitrary File Deletion primitive to delete the <code>C:\Config.Msi</code> folder data stream (<code>C:\Config.Msi::$INDEX_ALLOCATION</code>).<br>
					Implementing these changes in our previous <a href="#par5">exploit</a>, we should get something like this:<br>
				</h3>
			</p>
			
		</div>
		
		<img src="media/AFD2LPE.png" alt="" title="Exploit modified to gain a Local Privilege Escalation">
		
		<div>
			<p>
				<h3>
					<a href="https://github.com/LucaBarile/CVE-2022-38604/tree/main/Exploits/AFD2LPE/Exploit.bat" target="_blank" rel="noopener noreferrer">Here</a> you can find the modified exploit.<br>
					<br>
					Note:
					
					<ul>
						<li>
							<code>CreateMountPoint.exe</code>, <code>CreateSymlink.exe</code> and <code>FolderOrFileDeleteToSystem.exe</code> must be in the same folder of <code>Exploit.bat</code>
						</li>
						
						<li>
							This is just a draft; I haven't tested this exploit.
						</li>
						
						<li>
							<code>FolderOrFileDeleteToSystem.exe</code> isn't reliable at 100% because it must win a race condition.
						</li>
						
						<li>
							Since, with high probability, Wacom Driver will be uninstalled by the system administrator when he's logged in with his account, it makes no sense to bring up a <code>SYSTEM</code> command prompt to him &#128514;<br>
							<u>For example</u>, it would be more reasonable to modify <code>HID.DLL</code> so that, once it's running, it silently adds the unprivileged user's account to the administrators group.
						</li>
						
					</ul>
				</h3>
			</p>
		
			<p>
				<a name="par8"></a>
				<h2>From Arbitrary File Deletion to Windows Denial of Service &#129695;&#10060;</h2>
				<h3>
					Another idea would be to use our Arbitrary File Deletion primitive for a Windows Denial of Service attack.<br>
					If we want to deny the use of a particular program we could delete a file necessary for its proper functioning, therefore, in the same way, if we want to deny the user to use the Windows OS (preventing it from booting properly), we could delete a file necessary for its booting.<br>
					Searching a bit on the net I found various files necessary for Windows booting, but all of them can only be deleted by <a href="https://www.makeuseof.com/tag/what-is-trustedinstaller-and-why-does-it-keep-me-from-renaming-files/" target="_blank" rel="noopener noreferrer">TrustedInstaller</a>; <code>SYSTEM</code> and <code>Administrators</code> can only read and execute them (as shown in <a href="media/TrustedInstaller.png" target="_blank" rel="noopener noreferrer">this</a> example).<br>
					Continuing my research I ended up on <a href="https://labs.redyops.com/index.php/2020/04/27/dos-via-arbitrary-folder-creation/" target="_blank" rel="noopener noreferrer">this</a> page, which made me discover a way (to create the <code>%windir%\system32\cng.sys</code> file (or folder)) to prevent Windows from booting and bring up the famous <a href="https://en.wikipedia.org/wiki/Blue_screen_of_death" target="_blank" rel="noopener noreferrer">BSoD</a>, but we've only an Arbitrary File Deletion primitive, therefore we can't create any file or folder.<br>
					At this point I decided to switch to a "fail-and-fix" approach, starting to delete some files (potentially necessary for Windows booting) using the Administrator account and looking at what happened on reboot.<br>
					The following summary table illustrates all the attempts, gradually more selective, made to find one or more files that the Admin can delete and which, if deleted, will bring up the BSoD on reboot:<br><br>
					
					<table border="2" align="center">
					
						<tr>
							<td>CMD command</td>
							<td align="center">BSoD on reboot</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows" /s /q</code></td>
							<td align="center" style="color:green">YES</td>
						</tr>
						
						<tr>
							<td><code>del "C:\Windows\*.*"</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\Servicing\LCU" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32" /s /q</code></td>
							<td align="center" style="color:green">YES</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\Drivers" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\0409" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\AdvancedInstaller" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\am-et" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\AppLocker" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\appraiser" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\ar-SA" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\bg-BG" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\Boot" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\BthProps" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\CatRoot2" /s /q</code></td>
							<td align="center" style="color:red">NO</td>
						</tr>
						
						<tr>
							<td><code>rmdir "C:\Windows\System32\CatRoot" /s /q</code></td>
							<td align="center" style="color:green">YES</td>
						</tr>
						
						<tr>
							<td><code>del "C:\Windows\System32\CatRoot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\*.*"</code></td>
							<td align="center" style="color:green">YES</td>
						</tr>
						
						<tr>
							<td>
								<code>del "C:\Windows\System32\CatRoot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\Microsoft-Windows-Client-Desktop-Required-Package0516~31bf3856ad364e35~amd64~~10.0.19041.1826.cat"</code><br>
								<code>del "C:\Windows\System32\CatRoot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\Microsoft-Windows-Client-Desktop-Required-Package0416~31bf3856ad364e35~amd64~~10.0.19041.508.cat"</code>
							</td>
							<td align="center" style="color:green">YES</td>
						</tr>
						
					</table>
					
					<br>
					From the attempts listed in the table above I verified that, by deleting <code>Microsoft-Windows-Client-Desktop-Required-Package0516~31bf3856ad364e35~amd64~~10.0.19041.1826.cat</code> and <code>Microsoft-Windows-Client-Desktop-Required-Package0416~31bf3856ad364e35~amd64~~10.0.19041.508.cat</code>, the BSoD will appear on reboot.<br>
					Most likely also deleting other files located in the <code>{F750E6C3-38EE-11D1-85E5-00C04FC295EE}</code> folder is sufficient to bring up the BSoD, but I was unable to bring it up by deleting less than two files (I confess that my search was not exhaustive &#128556;).<br>
					Even more likely, there're other files located somewhere in the <code>System32</code> folder (or some of its subdirectories) which, if deleted by the admin, will bring up the BSoD on reboot.<br>
					If you find a single file located in the <code>Windows</code> folder (or some of its subdirectories), erasable by the administrator which, if deleted, will bring up the BSoD on reboot, send me a mail at <i>luca.barile.research@gmail.com</i>, please.<br>
					<br>
					The <a href="https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/windowsdesktop" target="_blank" rel="noopener noreferrer">Microsoft Windows Client Desktop</a> Required Package is divided into numbered sub-packages. The criterion I used to identify which sub-packages to delete to gain the BSoD on reboot was to list them and delete the two largest ones (<code>Package0516</code> and <code>Package0416</code> in my case), according to the idea that the more information you delete, the worse it is &#128517;<br>
					It may be that your packages are numbered differently; take note of the two largest.<br>
					It may be that the <code>{F750E6C3-38EE-11D1-85E5-00C04FC295EE}</code> folder <del>has a different name on your pc</del> (its name is a <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/222af2d3-5c00-4899-bc87-ed4c6515e80d" target="_blank" rel="noopener noreferrer">Curly Braced GUID String</a>); take note of its name.<br>
					<br>
					At this point we just have to modify our exploit in order to delete the two largest Microsoft Windows Client Desktop sub-packages found, and restart the computer to bring up the BSoD on reboot.<br>
					As I wrote <a href="#par3">here</a>, during the uninstallation process, <code>Remove.exe</code>, tries to remove three different files (<code>Wacom_Tablet.dat</code>, <code>Tablet.dat</code> and <code>WacomTouch.xml</code>) from folders on which the regular user has full control. So, in a similar way to what has already been done in the previous <a href="#par5">exploit</a>, we can delete three files instead of one, using NTFS volume mount points and symbolic links (in this case we just need to delete two files (I chose <code>Tablet.dat</code> and <code>WacomTouch.xml</code>)):
				</h3>
			</p>
		</div>
			
		<img src="media/AFD2WDOS.png" alt="" title="Exploit modified to gain a Windows Denial of Service">
			
		<div>
			<p>
				<h3>
					In this case we need to delete the <code>%AppData%\WTablet</code> folder before creating the mount point, because it could exist and contain files (unlike the <code>%UserProfile%\WTablet</code>).<br>
					If everything works fine, you should be able to bring up the BSoD on reboot, as shown in my following PoC:
				</h3>
			</p>
		</div>
		
		<img src="media/POC_WDOS.gif" alt="" title="Exploit modified to gain a Windows Denial of Service">
		
		<div>
			<p>
				<h3>
					<a href="https://github.com/LucaBarile/CVE-2022-38604/tree/main/Exploits/AFD2WDOS/Exploit.bat" target="_blank" rel="noopener noreferrer">Here</a> you can find the modified exploit.<br>
					<br>
					Note:<br>
					If you want to delete three sub-packages instead of two, to increase the chances of getting a BSoD on reboot, you can also take advantage of the <code>Wacom_Tablet.dat</code> file, in the same way we've exploited <code>WacomTouch.xml</code>.<br>
					Deleting multiple files (<a href="#par3">max 12</a>) is also possible, knowing the order in which <code>Remove.exe</code> deletes files and using an opportunistic lock.<br>
					The idea is to lock <code>Remove.exe</code> (via the opportunistic lock) after it has deleted the first file, change the symbolic link, unlock <code>Remove.exe</code> (by releasing the opportunistic lock) and relock it after it has deleted the second file.<br>
					The procedure must be repeated up to the last file, and obviously requires a slightly more complex exploit code.
				</h3>
			</p>
			
			<p>
				<a name="par9"></a>
				<h2>Something more on CatRoot folder &#128193;</h2>
				<h3>
					What is <code>CatRoot</code> folder for?<br>
					What kind of files does it contain?<br>
					What are the files contained in it for?<br>
					Why are some of them needed for Windows booting?<br>
					<a href="https://mywindowshub.com/what-are-catroot-and-catroot2-folders-how-to-reset-the-folder/" target="_blank" rel="noopener noreferrer">Here</a> and <a href="https://www.thewindowsclub.com/catroot-catroot2-folder-reset-windows" target="_blank" rel="noopener noreferrer">here</a> you can find some answers to the above questions; I'll try to summarize the information that I found on the net in a nutshell...<br>
					The <code>CatRoot</code> folder is necessary for the <a href="https://it.wikipedia.org/wiki/Windows_Update" target="_blank" rel="noopener noreferrer">Windows Update</a> process because it's responsible for storing the Windows Update Package (saved as <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files" target="_blank" rel="noopener noreferrer">Catalog Files</a> (<code>.cat</code>)), and takes active part in their installation.<br>
					During the Windows Update process the <code>CatRoot</code> files are also necessary to deploy the <code>%windir%\System32\catroot2\edb.log</code> log file, and the Windows updates are temporarily stored in the <code>%windir%\SoftwareDistrubution</code> folder before being installed.<br>
					The <code>.cat</code> files are digitally-signed and are used as a digital signature for an arbitrary collection of files. Every <code>.cat</code> file contains a collection of cryptographic hashes (thumbprints), and each thumbprint corresponds to a file that is included in the collection.<br>
					For example, if you want to use a new device under Windows, you need to install its driver package, which consists of a collection of software components necessary for the proper functioning of the device.<br>
					When you plug the device to your PC for the first time, the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-plug-and-play" target="_blank" rel="noopener noreferrer">Plug and Play (PnP)</a> Windows component recognizes the digitally-signed <code>.cat</code> file of that particular device driver package, and check that every software component included in the package corresponds to the relative thumbprints included in the <code>.cat</code> file.<br>
					If even one software doesn't match its relative thumbprint, the whole driver package is considered invalid, and won't be installed.<br>
					This technique prevents the installation of possible ad hoc modified drivers by an attacker for malicious purposes.<br>
					The <code>CatRoot</code> folder contains many <code>.cat</code> files, each related to a particular package of some product.<br>
					In our case, among the different packages, there were many packages related to Microsoft Windows Client Desktop and, among these packages, two of them are certainly needed for Windows booting: <code>Microsoft-Windows-Client-Desktop-Required-Package0516</code> and <code>Microsoft-Windows-Client-Desktop-Required-Package0416</code>.<br>
					I don't know why they are needed for Windows booting but, based on what I've just said, I assume that, while the operating system is loading, Windows checks the integrity of, at least, some Windows Client Desktop packages, including packages 516 and 416. As the <code>.cat</code> files related to these packages have been deleted, Windows can't verify their integrity and will consider them invalid, causing problems to the Windows Client Desktop software and, consequently, to the start of the Windows booting itself.<br>
					As you can see from the previous PoC, once the BSoD appears, Windows starts its auto-repair procedure to try to fix the problem but, despite the various attempts, it fails.<br>
					So, if some files located in the <code>CatRoot</code> folder are crucial for the correct Windows booting, why doesn't Windows make a backup copy of them, accessible only by TrustedInstaller, to be restored during the auto-repair procedure?<br>
					Or why not assign write access to these files only to TrustedInstaller? &#129300;
				</h3>
			</p>
			
			<p>
				<a name="par10"></a>
				<h2>How to fix the vulnerability &#128657;</h2>
				<h3>
					First of all I recommend to the developers to avoid removing, during the uninstallation process carried out by <code>Remove.exe</code>, the files (or folders) that were never created during the Wacom Driver installation process (like <code>%UserProfile%\WTablet</code>).<br>
					Secondly, to fix the vulnerability, it's sufficient that <code>Remove.exe</code> <a href="https://docs.microsoft.com/en-us/windows/win32/com/impersonation" target="_blank" rel="noopener noreferrer">impersonates</a> the user while deleting files and folders over which the regular user has full control. By doing this, the link following attack will fail because when <code>Remove.exe</code> will be redirected, it will only be able to delete files that the user can already delete on his own.
				</h3>
			</p>
		
			<p>
				<a name="par11"></a>
				<h2>Vulnerability disclosure timeline &#128197;</h2>
				<h3>
					First of all, I checked if the vendor has launched a bug bounty program but, unfortunately, Wacom Technology Corporation has none and the only page where you can report something (<a href="https://support.wacom.com/hc/en-us/requests/new" target="_blank" rel="noopener noreferrer">this</a>), doesn't speak explicitly of any acknowledgement (neither meritocratically nor economically).<br>
					At this point I followed the MITRE <a href="https://cve.mitre.org/cve/researcher_reservation_guidelines" target="_blank" rel="noopener noreferrer">researcher reservation guidelines</a> and, since Wacom Technology Corporation isn't on the <a href="https://www.cve.org/PartnerInformation/ListofPartners" target="_blank" rel="noopener noreferrer">CNAs partner list</a>, the only two remaining possibilities were to contact the CNA of Last Resort (<a href="https://cve.mitre.org/about/terminology.html#cna-lr" target="_blank" rel="noopener noreferrer">CNA-LR</a>) through the <a href="https://cveform.mitre.org/" target="_blank" rel="noopener noreferrer">CVE Request web form</a> or a <a href="https://cve.mitre.org/cve/researcher_reservation_guidelines#process#4" target="_blank" rel="noopener noreferrer">third-party coordinator CNAs</a> (read <a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/a-simple-guide-to-getting-cves-published/" target="_blank" rel="noopener noreferrer">this</a> interesting article for more information on how to get a CVE published).<br>
					Since the CNA of Last Resort, as the word itself says, is <u>the last resort</u> (&#127965;&#65039;), I looked for a third-party CNA in the CNAs list and decided to contact the <a href="https://www.zerodayinitiative.com/" target="_blank" rel="noopener noreferrer">Zero Day Initiative</a> CNA.<br>
					ZDI relieves you from the burden of tracking the bug with the vendor, <u>could</u> make a monetary offer to the researcher (CNA of Last Resort doesn't), follows a <a href="https://www.bugcrowd.com/resource/what-is-responsible-disclosure/" target="_blank" rel="noopener noreferrer">responsible vulnerability disclosure</a> policy and has a <a href="https://www.zerodayinitiative.com/about/benefits/" target="_blank" rel="noopener noreferrer">loyalty program</a> (CNA of Last Resort doesn't). You can learn more about their disclosure policy <a href="https://www.zerodayinitiative.com/advisories/disclosure_policy/" target="_blank" rel="noopener noreferrer">here</a>.
					
					<ul>
						<!-- Italy (Milano) GMT+1 | ZDI (??) GMT-6 | Milano is 7h ahead of ZDI-->
						<li>2022-07-20 (GMT+1) - I discovered the vulnerability.</li>
						<li>2022-07-21 (GMT-6) - I reported the vulnerability to ZDI (CASE OPENED).</li>
						<li>2022-07-22 (GMT-6) - ZDI assigned the case (CASE ASSIGNED).</li>
						<li>2022-08-15 (GMT-6) - ZDI investigated the case (CASE INVESTIGATED).</li>
						<li>2022-08-18 (GMT+1) - ZDI replied that they aren't interested in this vulnerability because having an administrator uninstall the product is considered too much user interaction (CASE CLOSED) &#129300;</li>
					</ul>
						
					At this point the only alternative left is the CNA of Last Resort (CNA-LR), so I decided to use the CVE Request web form to report the vulnerability.<br>
					
					<ul>
						<li>2022-08-18 (GMT+1) - I submitted the vulnerability to CNA-LR.</li>
						<li>2022-08-18 (GMT+1) - CNA-LR assigned the ID 1315571 to my request.</li>
						<li>2022-09-16 (GMT+1) - CNA-LR reserved the CVE-2022-38604 ID for my vulnerability.</li>
						<li>2022-12-15 (GMT+1) - I asked to CNA-LR for an update (no answare...).</li>
						<li>2023-01-22 (GMT+1) - I asked to CNA-LR again for an update (no answare...).</li>
						<li>2023-02-22 (GMT+1) - I asked to CNA-LR again for an update (no answare...).</li>
						
						<li></li>
					</ul>
				</h3>
			</p>
		
			<p>
				<a name="par12"></a>
				<h2>Final considerations</h2>
				<h3>
					The references that have been useful to me to write this article and the exploit code are already present, in the form of links, in the previous paragraphs you have read and that make up this article.<br>
					The conclusions are very similar to those that I wrote in some of my previous articles (<a href="../ZDI-CAN-16318/lpe/index.html" target="_blank" rel="noopener noreferrer">1</a>, <a href="../ZDI-CAN-16318/arb_r/index.html" target="_blank" rel="noopener noreferrer">1.1</a>, <a href="../ZDI-CAN-16318/arb_rw/index.html" target="_blank" rel="noopener noreferrer">1.2</a> and <a href="../ZDI-CAN-16857/index.html" target="_blank" rel="noopener noreferrer">2</a>) and concern the logical vulnerabilities and the link following attack technique.<br>
					The vulnerability I described in this article is just another example of a logical vulnerability discovered through dynamic analysis using Process Monitor and, if you've read my previous articles related to logical vulnerabilities, I think that the paragraphs that might be most interesting for you are <a href="#par7">this</a> and <a href="#par8">this</a>.
				</h3>
			</p>

		</div>
		
		<br>
		
		<hr>
		
		<h3 align="center">
			<i>If you liked this article, what do you think about buying me a unicorn? <a href="https://www.buymeacoffee.com/LucaBarile" target="_blank" rel="noopener noreferrer">Yeees! I'll buy it for you!</a></i> &#129412;
		</h3>
		
	</body>
</html>