<!DOCTYPE html>

<!-- https://www.amp-what.com/unicode/search/icon -->
<!-- Serif - Times - Times New Roman (default font) -->

<html lang="en">

	<head>
		
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="Report of a Microsoft Excel Denial of Service Vulnerability caused by an incorrect way of handling particular types of charts">
		<meta name="keywords" content="Microsoft Excel, Excel, Vulnerability, CVE-2023-23396, KB5002362, KB5002356, DoS, Denial of Service, Excel DoS, Excel Denial of Service, Exploit, chart, charts, thread, Memory exhaustion, RAM exhaustion, CPU usage, Report, Write-Up, Writeup, Paper, White paper, Full disclosure, Disclosure, MSRC">
		<meta name="author" content="Luca Barile">
		
		<link rel="stylesheet" href="../postsStyle.css">
		
		<title>CVE-2023-23396</title>
    
	</head>

	<body bgcolor="black" text="DarkGray" link="lightblue" alink="gold" vlink="DarkRed">
	
		<h1>Microsoft Excel Denial of Service Vulnerability</h1>
		<h2 align="center" style="color:white">CVE-2023-23396</h2>
		
		<div>
			<p>
				<h2 align="center">Table of Contents &#128220;</h2>
				<h3>
					<table border="1" align="center">
						<tr>
							<td>
								<ol>
									<li><a href="#par_1">An unsought vulnerability (TL;DR)</a></li>
									<li><a href="#par_2">From curiosity to vulnerability</a></li>
									<li><a href="#par_3">An .XLSX file is a zipped file!</a></li>
									<li><a href="#par_4">Analyzing chart2.xml to find the cause of the issue</a></li>
									<li><a href="#par_5">Studying to Understand</a></li>
									<li><a href="#par_6">A value that shouldn't be considered</a></li>
									<li><a href="#par_7">Lots of grid lines! Lots and lots!!</a></li>
									<li><a href="#par_8">The Exploit</a></li>
									<li><a href="#par_9">What the hell are the threads doing?</a></li>
									<li><a href="#par_10">Open questions</a></li>
									<li><a href="#par_11">How to fix the vulnerability</a></li>
									<li><a href="#par_12">Vulnerability disclosure timeline</a></li>
									<li><a href="#par_13">Patch analysis</a></li>
									<li><a href="#par_14">Conclusion</a></li>
									<li><a href="#par_15">References</a></li>
								</ol>
							</td>
						</tr>
					</table>
				</h3>	
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_1"></a>
				<h2>An unsought vulnerability (TL;DR) &#129714;</h2>
				<h3>
					Yes, this time I wasn't looking for any vulnerability (and Microsoft Excel has never been one of my targets).<br>
					Towards the end of 2022 I taught the first part of the Computer Science course for the students of an Higher Technical Institute (ITS) with which I collaborated and, in November 2022, I assigned them a test concerning the Microsoft Office suite (focused on Word, Excel and PowerPoint).<br>
					During the computer test the students could carry out an exercise in Word, one in Excel and one in PowerPoint; each exercise provided a certain score and, by completing all three exercises correctly, it was possible to obtain the maximum score.<br>
					The exercise in Excel required to reproduce the content of the following image in an <code>.xlsx</code> file.
				</h3>
			</p>
		</div>
		
		<a name="excel_exercise"></a>
		<img src="media/excel_exercise.png" alt="" title="Exercise to be reproduced in Excel by the student">
		
		<div>
			<p>
				<h3>
					During the test everything went well but, once the available time was up, a student was unable to save the exercise he had done in Excel.<br>
					Analyzing the system status with the Windows Task Manager, it turned out that the  <code>Excel.exe</code> process was using the CPU and almost all the available RAM intensively.<br>
					By assigning (from the Task Manager) the <code>High</code> priority to <code>Excel.exe</code> and waiting about ten minutes, <code>Excel.exe</code> was able to complete the save operation by saving the work done by the student in an <code>.xlsx</code> file (but the process was still using the CPU and almost all the available RAM intensively &#129300;).<br>
					A few days later, checking all the exercises done by the students, I opened the aforementioned <code>.xlsx</code> file; immediately <code>Excel.exe</code> (I was using <u>Microsoft Excel for Microsoft 365 MSO</u> (<u>Version 2202 Build 16.0.14931.20858</u>) <u>64-bit</u>) began to use the CPU and almost all the RAM memory intensively, causing a Denial of Service condition on the system and preventing me from checking the contents of the spreadsheet in a reasonable time.<br>
					Opening the <code>.xlsx</code> file with <a href="https://it.libreoffice.org/" target="_blank" rel="noopener noreferrer">LibreOffice</a>, no heavy CPU\RAM usage has been reported, and I was able to check the contents of the spreadsheet without problems. This led me to think that the problem wasn't the <code>.xlsx</code> file (eg corrupted file), but the way Excel represented its contents.<br>
					At this point I thought it would be interesting to understand what was the exact cause that led <code>Excel.exe</code> to use RAM and CPU so intensively, but I still had other exercises to check and things to do, so I decided to let it go.
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_2"></a>
				<h2>From curiosity to vulnerability &#129300;&#10145;&#65039;&#129714;</h2>
				<h3>
					In the following days I remembered the issue concerning the student's <code>.xlsx</code> file; I was curious about the exact cause of the problem.<br>
					Thinking that discovering it would lead to something interesting, let it all go would be a wasted opportunity and having more time available, I decided to further investigate the issue.<br>
					I opened that <code>.xlsx</code> file again and, looking closely, noticed that the first chart (shown on the left in <a href="#excel_exercise">this</a> image) was visible, but the following image was shown in place of the second chart (shown on the right).
				</h3>
			</p>
		</div>
		
		<img src="media/chart_loading.png" alt="" title="Temporary image shown while Excel tries to load the chart">
		
		<div>
			<p>
				<h3>
					The image above is generally shown as a temporary image, until Excel has performed all the operations necessary to show the graphic element that the user must see (the second chart in this case).<br>
					The second chart is never displayed, this means that the operations necessary to display it never end. In fact, the Task Manager reveals that, in the meantime, the <code>Excel.exe</code> process is using the CPU and almost all the available RAM intensively.<br>
					At this point I assumed that the problem is caused by some setting of the chart (set by the student during its creation) which induces <code>Excel.exe</code> into a sort of infinite loop during its loading.<br>
					But how can I know which chart settings the student has set?<br>
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_3"></a>
				<h2>An .XLSX file is a zipped file!</h2>
				<h3>
					Searching the net I found out that an <code>.xlsx</code> file is a zipped file and its format is an <a href="https://support.microsoft.com/en-us/office/open-xml-formats-and-file-name-extensions-5200d93c-3449-4380-8e11-31ef14555b18" target="_blank" rel="noopener noreferrer">XML-based file format</a>.<br>
					In fact, each content (and its related settings) entered by the user into the spreadsheet, is stored in the form of an <code>.xml</code> file.<br>
					Each <code>.xml</code> file is stored in a precise folder, and all folders are zipped into an <code>.xlsx</code> file.<br>
					To view the different <code>.xml</code> files, just change the <code>.xlsx</code> file extension to <code>.zip</code> and unzip its content.<br>
					If you unzip the contents of an empty <code>.xlsx</code> file, you should see this:
				</h3>
				
				<img src="media/empty_xlsx_contents.png" alt="" title="Contents of an empty .xlsx file">
				
				<h3>
					An <code>.xlsx</code> file content can be "Primary" or "Secondary".<br>
					A "Primary" content is a content which you can see and access through Excel (eg cell contents, images and charts).<br>
					A "Secondary" content is a content you can't see, but still necessary for your Excel file to work (eg metadata and shared strings).
				</h3>
				
				<img src="media/xlsx_file_contents_types.png" alt="" title="Type of .xlsx file contents">
				
				<h3>
					If you're interested to examine in depth the structure and content of an <code>.xlsx</code> file, I suggest you read <a href="https://professor-excel.com/xml-zip-excel-file-structure/" target="_blank" rel="noopener noreferrer">this</a> article, from which I took the previous two images and summarized some concepts.<br>
					For our purposes however, it's not necessary to go further because we're now able to answer the question that ended the previous paragraph.<br>
					The chart settings the student has set are easily found by browsing the unzipped folders: they're stored in the <code>xl\charts\chart2.xml</code> file.<br>
					The <code>xl</code> folder contains the actual content of the student's <code>.xlsx</code> file, <code>charts</code> contains all the charts created by the student (and all their "secondary" contents, like colors and styles) and <code>chart2.xml</code> is the file containing the chart settings we want to analyze.<br>
				</h3>
				
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_4"></a>
				<h2>Analyzing chart2.xml to find the cause of the issue &#128269;</h2>
				<h3>
					If my assumption is right, it should be possible to find in <code>chart2.xml</code> one or more settings set by the student that trigger the Excel vulnerability. The idea to find these settings is as follows:
					
					<ol>
						<li>
							Create a new <code>.xlsx</code> file (<code>test.xlsx</code>) containing only a chart of the same type (<a href="https://support.microsoft.com/en-us/topic/present-your-data-in-a-scatter-chart-or-a-line-chart-4570a80f-599a-4d6b-a155-104a9018b86e" target="_blank" rel="noopener noreferrer">scatter chart</a>) and with the same values of the one created by the student, without changing its default settings.
						</li>
						
						<li>
							Note any differences between <code>chart2.xml</code> and the <code>.xml</code> file containing the settings of the newly created chart (let's call it <code>fakeChart.xml</code>).
						</li>
						
						<li>
							Change the <code>fakeChart.xml</code> settings by adding one of those noted in step 2 (or a combination of them).
						</li>
						
						<li>
							Recreate a new <code>test.xlsx</code> file containing the <code>fakeChart.xml</code> file created in step 3.<br>
							(Zip all files and folders into <code>test.zip</code> and change its extension to <code>.xlsx</code>).
						</li>
						
						<li>
							Open the newly create <code>test.xlsx</code> file in Excel.
						</li>
						
						<li>
							Keep repeating steps 3, 4 and 5 until the Excel vulnerability is triggered or all the notes noted in step 2 (or a combination of them) have all been tested.
						</li>
					</ol>
					
					If, at the end of this procedure, the Excel vulnerability has never been triggered then it means that my assumption is wrong, otherwise it means that it's right and the chart settings that trigger the vulnerability has been found.<br>
					Performing this procedure was very time consuming (even because, in the worst case, it's necessary to try all possible combinations of the settings (which are a lot &#128542;)) but, after many attempts, I did it! I found the two settings that must be present to trigger the Excel vulnerability (if one of the two is missing the vulnerability isn't triggered), proving the correctness of my initial assumption.<br>
					The two settings were located within one of the <code>&lt;c:valAx&gt;</code> tags of the <code>chart2.xml</code> file, and are as follows:<br>
					<br>
					...<br>
					<code>&lt;c:valAx&gt;</code><br>
					&nbsp;&nbsp;&nbsp;&nbsp;...<br>
					&nbsp;&nbsp;&nbsp;&nbsp;<code>&lt;c:max val=&quot;1&quot;&sol;&gt;</code> &larr; first setting<br>
					&nbsp;&nbsp;&nbsp;&nbsp;...<br>
					&nbsp;&nbsp;&nbsp;&nbsp;<code>&lt;c:delete val=&quot;1&quot;&sol;&gt;</code> &larr; second setting<br>
					&nbsp;&nbsp;&nbsp;&nbsp;...<br>
					<code>&lt;&sol;c:valAx&gt;</code><br>
					...<br>
					<br>
					Great! But what do these two lines of code mean? What changes do they make to the chart? And why do they cause Excel to use almost all the available RAM of the system?<br>
					<br>
					PS:<br>
					Another idea that you can apply to find the settings that trigger the Excel vulnerability is the one symmetrical to the one previously described: you can reset all the chart settings (one at a time) set by the student by inserting their default values and, if opening the <code>text.xlsx</code> file the vulnerability is no longer triggered, it means that the settings just reset are the ones that trigger it.
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_5"></a>
				<h2>Studying to Understand &#128214;&#129300;</h2>
				<h3>
					To answer the previous questions I read the <a href="https://learn.microsoft.com/en-us/office/open-xml/understanding-the-open-xml-file-formats" target="_blank" rel="noopener noreferrer">Open XML file formats documentation</a>, studied some classes of the <a href="https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.drawing.charts" target="_blank" rel="noopener noreferrer">DocumentFormat.OpenXml.Drawing.Charts namespace</a> and observed how the chart changed by changing the values of the two previously indicated <code>&lt;c:valAx&gt;</code> settings (and vice versa).<br>
					Consider the following XML code of the <code>chart2.xml</code> file:<br>
					<br>
					<img src="media/chart_xml.png" alt="" title="chart2.xml code">
					<br>
					As you can see, there're four <code>&lt;c:valAx&gt;</code> tags but the two settings can <u>only</u> be found within the second tag (indicated by the green arrow).<br>
					Each <code>&lt;c:valAx&gt;</code> <a href="https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.drawing.charts.valueaxis?#remarks" target="_blank" rel="noopener noreferrer">tag</a> specifies a value axis of the chart and <code>chart2.xml</code> contains four because in a generic chart it's possible to have the following four value axes:
					
					<ul>
						<li>Primary Horizontal</li>
						<li>Secondary Horizontal</li>
						<li>Primary Vertical</li>
						<li>Secondary Vertical</li>
					</ul>
					
					The <code>&lt;c:valAx&gt;</code> tags seem to be arranged in a precise order and the second tag (the one containing the two settings) is the one relating to the Primary Vertical value axis.<br>
					In the following image you can see the correspondences between the four axes and the relative <code>&lt;c:valAx&gt;</code> tags:
				</h3>
			</p>
		</div>
		
		<img src="media/axes_correspondences.png" alt="" title="Correspondences between axes and tags">
		
		<div>
			<p>
				<h3>
					The first setting (indicated in the following image by the gray arrow) is specified within the <code>&lt;c:scaling&gt;</code> sub-tag while the second (indicated by the purple arrow) directly within the <code>&lt;c:valAx&gt;</code> tag:<br>
					<br>
					<img src="media/settings.png" alt="" title="Location of the two settings">
					<br>
					The <code>&lt;c:scaling&gt;</code> sub-tag <a href="https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.drawing.charts.scaling?#remarks" target="_blank" rel="noopener noreferrer">contains additional axis settings</a> which, in this case, are the orientation of the axis (<code>&lt;c:orientation&gt;</code> <a href="https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.drawing.charts.orientation?#remarks" target="_blank" rel="noopener noreferrer">tag</a>) and its maximum value (<code>&lt;c:max&gt;</code> <a href="https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.drawing.charts.maxaxisvalue?#remarks" target="_blank" rel="noopener noreferrer">tag</a>).<br>
					As you can see, the orientation value is set to <code>minMax</code> and this means that the axis values must be displayed from minimum to maximum (the opposite effect can be obtained by setting the value to <code>maxMin</code>); the max value is set to <code>1</code> and this means that the maximum value of the axis must be <code>1</code> (so, as a consequence, the chart lines exceeding this value won't be shown).<br>
					Instead, the <code>&lt;c:delete&gt;</code> <a href="https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.drawing.charts.delete?#remarks" target="_blank" rel="noopener noreferrer">tag</a> means that the axis shall be deleted from the chart (that is, it won't be visible to the user).<br>
					<br>
					In a nutshell, the two settings that trigger the Excel vulnerability do nothing but set the maximum value of the Primary Vertical value axis to <code>1</code> and delete the axis itself (make it invisible in the chart).<br>
					All this doesn't make sense! &#128561;<br>
					It makes no sense to set the maximum value of an axis if the axis is not displayed in the chart... However, this is the cause of the problem, how is this possible? This case is getting more and more interesting &#129300;
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_6"></a>
				<h2>A value that shouldn't be considered &#9940;</h2>
				<h3>
					To understand something more, I created new <code>.xlsx</code> files (each one with their own scatter chart), setting for each scatter chart different values of the <code>&lt;c:max&gt;</code> and <code>&lt;c:delete&gt;</code> tags (using the Excel User Interface), with the hope of being able to trigger the vulnerability.<br>
					In particular, I used a Combo chart with a Custom Combination. For both the Series (Series1 and Series2) I chose the Chart Type &quot;Scatter with Straight Lines&quot; and, only for Series1, I selected &quot;Secondary Axis&quot;.<br>
					I decided to use this type of chart, with these settings, because this is the chart that was requested in the assignment and created by the student.<br>
					Below you can see how to create this type of chart:
				</h3>
			</p>
		</div>
		
		<a name="combo_chart_creation"></a>
		<img src="media/combo_chart_creation.gif" alt="" title="Combo chart creation process">
		
		<div>
			<p>
				<h3>
					As a starting point I decided to keep the Primary Vertical value axis (which, for simplicity, I'll call PVVA from now on) visible (<code>&lt;c:delete val=&quot;0&quot;/&gt;</code>) and see how the chart changed by setting its maximum value (I used <code>1</code> as a test) and leaving it unset (in this case its default value is used: <code>Auto</code>).<br>
					By setting its maximum value to <code>1</code> the <code>&lt;c:max val=&quot;1&quot;/&gt;</code> tag is written within the <code>&lt;c:scaling&gt;</code> tag, otherwise it isn't written at all (this means that the <code>&lt;c:max .../&gt;</code> tag can be found within the <code>&lt;c:scaling&gt;</code> tag only if the user set a maximum value of the axis).<br>
					Let's call <code>CASE 2</code> the case in which the maximum value of the PVVA is set to <code>1</code> and <code>CASE 1</code> the case in which its value is left unset (this is the default case used by Excel when the user creates a new chart; in this case Excel sets a maximum value that fits well with the values that are to be represented in the chart).<br>
					In <code>CASE 1</code>, when the chart lines exceed the maximum value of the PVVA, Excel automatically changes its scale (and therefore also its maximum value) and draws new equidistant (horizontal) grid lines, so that all lines of the chart are entirely visible.<br>
					In <code>CASE 2</code>, when the chart lines exceed the maximum value of the PVVA, the scale doesn't change, the (horizontal) grid lines remain equidistant and only the part of the chart that falls within its maximum value is displayed (therefore some lines of the chart aren't entirely visible).<br>
					Below you can see how Excel handles the two cases:
				</h3>
			</p>
		</div>
		
		<img src="media/case1_case2.gif" alt="" title="How Excel handles CASE 1 and CASE 2">
		
		<div>
			<p>
				<h3>
					Running these tests the vulnerability hasn't been triggered, but I expected it because the PVVA has always remained visible (<code>&lt;c:delete val=&quot;0&quot;&sol;&gt;</code>) while, as we've seen previously, the vulnerability is triggered when it isn't (<code>&lt;c:delete val=&quot;1&quot;&sol;&gt;</code>).<br>
					So I deleted the PVVA (<code>&lt;c:delete val=&quot;1&quot;&sol;&gt;</code>), saved the file (forcing Excel to write the <code>&lt;c:delete val=&quot;1&quot;&sol;&gt;</code> tag within the <code>.xml</code> file related to the chart (<code>chart1.xml</code>)) and changed the values of the chart, both in <code>CASE 1</code> and in <code>CASE 2</code>.<br>
					In <code>CASE 1</code> nothing unexpected has happened: since I deleted the PVVA, Excel, during the creation of the chart, has referred to the Secondary Vertical value axis (which, for simplicity, I'll call SVVA from now on) and, when the chart lines have exceeded its maximum value, Excel automatically changed its scale (because, by default, the SVVA has the maximum value set to <code>Auto</code>) and drew new equidistant (horizontal) grid lines, so that all lines of the chart were entirely visible.<br>
					In <code>CASE 2</code> however, something unexpected happened!<br>
					I expected that, also in this case, Excel would behave as in <code>CASE 1</code> since I deleted the PVVA, therefore its maximum value (which is one of its many properties) should no longer be considered, but I was wrong.<br>
					In this case Excel, during the creation of the chart, behaves as in <code>CASE 1</code> until it has to draw the (horizontal) grid lines: <u>it draws too many lines</u>!<br>
					Looking carefully at what happens it can be seen that, during the creation of the chart, the number of (horizontal) grid lines is calculated as if they were to be displayed on the PVVA, even if it has been deleted.<br>
					Before deleting it, the number of (horizontal) grid lines established by Excel was (<u>I don’t consider the first grid line to simplify calculations</u>) <u>10 for each unit</u> (the number is decided by Excel <u>based on the maximum value of the PVVA</u>, so that the (horizontal) grid lines are neither too many nor too few), and that value was a <u>fixed value</u> because, since the PVVA had a maximum value, its scale would never change (because only the part of the chart that falls within its maximum value would have been displayed).<br>
					This means that if the user sets the maximum value of the PVVA and then decides to delete the axis, when the chart lines exceed the maximum value of the SVVA, Excel changes its scale to be able to display all lines of the chart but, <u>mistakenly</u>, <u>continues to use the  fixed value used to draw the</u> (horizontal) <u>grid lines of the PVVA</u> (10 for each unit of the axis) <u>also to draw the</u> (horizontal) <u>grid lines of the SVVA</u>.<br>
					Since the fixed value of (horizontal) grid lines established by Excel was 10 for each unit, an increase of n unit in the SVVA corresponds to an increase of 10*n grid lines to be displayed in the chart, as shown in the following table:<br>
					<br>
					<table border="2" align="center">
						<th style="color:orange">SVVA units</th><th style="color:red">Grid lines drawn</th>
						<tr><td style="color:orange">1</td><td style="color:red">10</td></tr>
						<tr><td style="color:orange">1,2</td><td style="color:red">12</td></tr>
						<tr><td style="color:orange">2</td><td style="color:red">20</td></tr>
						<tr><td style="color:orange">2,5</td><td style="color:red">25</td></tr>
						<tr><td style="color:orange">3</td><td style="color:red">30</td></tr>
						<tr><td style="color:orange">3,5</td><td style="color:red">35</td></tr>
						<tr><td style="color:orange">...</td><td style="color:red">...</td></tr>
						<tr><td style="color:orange">n</td><td style="color:red">10*n</td></tr>
					</table>
					<br>
					Below you can see the unexpected way Excel handles the <code>CASE 2</code>:
				</h3>
			</p>
		</div>
		
		<a name="the_vulnerability"></a>
		<img src="media/vulnerability.gif" alt="" title="Excel continues to consider the maximum value of the PVVA">
		
		<div>
			<p>
				<h3>
					Ok... Excel, in this particular scenario (<code>CASE 2</code>), doesn't handle (horizontal) grid lines well, but this wasn't enough to trigger the vulnerability because, except this, it continued to work properly. Can we say: "close but not cigar"? &#128685;
				</h3>
			</p>
			
			<p>
				<a name="par_7"></a>
				<h2>Lots of grid lines! Lots and lots!! &#128200;</h2>
				<h3>
					Continuing to increase the number of grid lines we can see that, at some point, there will be so many to have the impression that the chart has a gray background.<br>
					Adding even more grid lines, Excel will stop responding for a certain period of time, after which it will resume working normally but with an increasingly higher <a href="https://learn.microsoft.com/en-us/windows/win32/procthread/process-working-set" target="_blank" rel="noopener noreferrer">working set</a>.<br>
					Finally, as you can see below, when the number of grid lines exceeds a certain threshold, Excel will no longer respond and will run out of memory, causing a Denial of Service condition on the system:
				</h3>
			</p>
		</div>
		
		<a name="triggering_the_vulnerability"></a>
		<img src="media/triggering_the_vulnerability.gif" alt="" title="Triggering the Excel DoS vulnerability">
		
		<div>
			<p>
				<h3>
					I collected the following data (on a system with 16GB of RAM and an Intel Core i5-9600K CPU &#64; 3.70GHz) to understand how Excel's non-response time and its working set changed according to the number of grid lines, setting, as in the previous examples, the maximum value of the PVVA to 1 (<code>&lt;c:max val=&quot;1&quot;&sol;&gt;</code>):<br>
					<br>
					<table border="2" align="center">
						<th style="color:orange">Grid lines number</th>
						<th style="color:gold">Working set</th>
						<th style="color:lightblue">Non-response time</th>
						<th style="color:red">Prolonged DoS</th>
						
						<tr>
							<td style="color:orange">1 000 000</td>
							<td style="color:gold">1.2 GB</td>
							<td style="color:lightblue">&sim;1 seconds</td>
							<td style="color:red">NO</td>
						</tr>
						
						<tr>
							<td style="color:orange">5 000 000</td>
							<td style="color:gold">5.1 GB</td>
							<td style="color:lightblue">&sim;6 seconds</td>
							<td style="color:red">NO</td>
						</tr>
						
						<tr>
							<td style="color:orange">5 500 000</td>
							<td style="color:gold">5.25 GB</td>
							<td style="color:lightblue">&sim;6.5 seconds</td>
							<td style="color:red">NO</td>
						</tr>
						
						<tr>
							<td style="color:orange">6 500 000</td>
							<td style="color:gold">7.4 GB</td>
							<td style="color:lightblue">&sim;9 seconds</td>
							<td style="color:red">NO</td>
						</tr>
						
						<tr>
							<td style="color:orange">7 000 000</td>
							<td style="color:gold">8.82 GB</td>
							<td style="color:lightblue">&sim;11.5 seconds</td>
							<td style="color:red">NO</td>
						</tr>
						
						<tr>
							<td style="color:orange">10 000 000</td>
							<td style="color:gold">10.95 GB</td>
							<td style="color:lightblue">&sim;17 seconds</td>
							<td style="color:red">NO</td>
						</tr>
						
						<tr>
							<td style="color:orange">UNKNOWN THRESHOLD</td>
							<td style="color:gold">EXHAUSTED</td>
							<td style="color:lightblue">&infin;</td>
							<td style="color:red">YES</td>
						</tr>
						
						<tr>
							<td style="color:orange">99 999 999 999</td>
							<td style="color:gold">EXHAUSTED</td>
							<td style="color:lightblue">&infin;</td>
							<td style="color:red">YES</td>
						</tr>
					</table>
					<br>
					I don't know if there is an exact number of grid lines (UNKNOWN THRESHOLD) beyond which, regardless of PC hardware performance, Excel will always end up in an infinite loop and will never be able to draw them all. Surely, however, in traditional domestic PCs of 2023, it's possible to make it draw a sufficiently high number of grid lines to bring the system into a very prolonged DoS condition.<br>
					<br>
					We were finally able to reproduce the Excel's vulnerable condition from scratch and exploit it &#9989;<br>
					In a nutshell:
					
					<ul>
						<li>
							The vulnerability lies in the way Excel handles the deletion of the PVVA (in which the maximum value has been set) of a chart in which the SVVA (in which the maximum value hasn't been set) is visible. In this case Excel deletes the PVVA but continues to use its maximum value to decide how many horizontal grid lines to draw in the chart, even if the SVVA has no maximum value set. This leads Excel to draw more grid lines than it should (within a limited space) if the scale of the SVVA increases during the chart building process.
						</li>
						
						<li>
							The vulnerability can be exploited to cause a DoS condition on the system by forcing Excel to greatly increase the scale of the SVVA. To do this just set specific chart data so that the chart lines greatly exceed the maximum value of the SVVA; in this way Excel is forced to change its scale to represent them.
						</li>
					</ul>
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_8"></a>
				<h2>The Exploit &#9760;&#65039;</h2>
				<h3>
					The exploit consists of a specially crafted <code>.xlsx</code> file which, once opened, exploits the vulnerability as I just described, bringing the system into a DoS condition.<br>
					To craft it we can think of reproducing the steps shown in the <a href="#triggering_the_vulnerability">previous animation</a>, setting the value in cell B2 to a very big number (eg <code>99999999999</code>) and saving the file. The problem is that, as soon as we set that value, the vulnerability is immediately triggered, Excel stops responding and we can't save the file because we will no longer be able to interact with its graphical interface.<br>
					To circumvent the problem we can create a new <code>.xlsx</code> file, a chart as shown <a href="#combo_chart_creation">here</a>, save the file and directly edit the <code>.xml</code> file related to the chart (<code>chart1.xml</code>) and the spreadsheet (<code>sheet1.xml</code>).<br>
					To get the vulnerable condition we must insert the tags <code>&lt;c:delete val=&quot;1&quot;&sol;&gt;</code> and <code>&lt;c:max val=&quot;1&quot;&sol;&gt;</code> in <code>...\xl\charts\chart1.xml</code>, while to set a high value (<code>99999999999</code> in my case) in cell B2 we must insert the tag <code>&lt;c r=&quot;B2&quot;&gt;&lt;v&gt;99999999999&lt;&sol;v&gt;&lt;&sol;c&gt;</code> in <code>...\xl\worksheets\sheet1.xml</code>.<br>
					After the appropriate changes it will be sufficient to zip the new files and change the extension of the zipped file to <code>.xlsx</code>. Opening the file, the vulnerability will be triggered immediately.<br>
					These are the steps to follow to craft our exploit:
				</h3>
			</p>
		</div>
		
		<img src="media/crafting_the_exploit.gif" alt="" title="Crafting the exploit">
		
		<div>
			<p>
				<h3>
					<a href="https://github.com/LucaBarile/CVE-2023-23396/raw/main/Exploit.xlsx" target="_blank" rel="noopener noreferrer">Here</a> you can download my exploit.
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_9"></a>
				<h2>What the hell are the threads doing? &#128530;</h2>
				<h3>
					With this paragraph, which concludes the descriptive part of the vulnerability, I want to delve a little deeper into what happens when Excel tries to draw a very large number of grid lines within a limited space.<br>
					As you can see from the animation below, using <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/procmon" target="_blank" rel="noopener noreferrer">Process Monitor</a> it's possible to see that, when Excel has to load or modify a chart, it creates a new thread (<code>Thread Create</code>) to which delegate the task (which also consists, among other things, of drawing the grid lines), in order to be ready to manage any user interactions with the spreadsheet.<br>
					To perform its task the thread needs to call some functions, including <code>Ordinal43+0x...</code>, <code>oart.dll+0x...</code> and <code>GetExportedInterface+0x...</code>.<br>
					<code>Ordinal43+0x...</code> is already loaded within the <code>EXCEL.EXE</code> module while <code>oart.dll+0x...</code> and <code>GetExportedInterface+0x...</code> functions are implemented, respectively, within the <code>oart.dll</code> and <code>chart.dll</code> modules (which, consequently, must be loaded into memory).<br>
					As reported <a href="https://devblogs.microsoft.com/cppblog/making-cpp-exception-handling-smaller-x64/" target="_blank" rel="noopener noreferrer">here</a> (and as the name itself suggests), <code>oart.dll</code> (Microsoft OfficeArt) provides graphics features that are shared between Office apps, while <code>chart.dll</code> (Microsoft Office Charting) exports <a href="https://strontic.github.io/xcyclopedia/library/CHART.DLL-B8584D809781C033E0927FC44052A989.html" target="_blank" rel="noopener noreferrer">many functions</a> that provide support for interacting with charts and graphs, and this is just what the thread needs.<br>
					If everything goes well, the thread performs its task successfully, terminates its execution (<code>Thread Exit</code>) and the user can see the chart in the spreadsheet.
				</h3>
			</p>
		</div>
		
		<img src="media/thread_delegation.gif" alt="" title="Excel delegates the chart loading process to a thread">
		
		<div>
			<p>
				<h3>
					However, if Excel must load a chart with billions of grid lines within a limited space, the thread fails to perform its task and other threads are created and terminated after a while. In particular, the thread with starting address <code>Ordinal43+0xb330</code>, increases more and more its number of <a href="http://www.wademan.com/blog/using-process-explorer" target="_blank" rel="noopener noreferrer">Delta Cycles</a> and the CPU \ RAM usage.<br>
					Using <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer" target="_blank" rel="noopener noreferrer">Process Explorer</a> it's possible to <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&seqNum=5" target="_blank" rel="noopener noreferrer">examine the thread activity</a> and see that, after several calls to functions <code>GetExportedInterface+0x...</code>, <code>ntoskrnl.exe</code> calls functions <code>KeSynchronizeExecution</code>, <code>KeWaitForSingleObject</code> and <code>KeAreAllApcsDisabled</code>.<br>
					From these calls we can assume that <code>ntoskrnl.exe</code> synchronizes the thread's task with the <a href="https://en.wikipedia.org/wiki/Interrupt_handler" target="_blank" rel="noopener noreferrer">Interrupt Service Routine</a> (<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kesynchronizeexecution" target="_blank" rel="noopener noreferrer">KeSynchronizeExecution</a>), puts it in a waiting state until it reaches the time limit or the dispatcher reactivates it (<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kewaitforsingleobject" target="_blank" rel="noopener noreferrer">KeWaitForSingleObject</a>), checks if it's inside a guarded region (<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-keareallapcsdisabled" target="_blank" rel="noopener noreferrer">KeAreAllApcsDisabled</a>), puts it back in a waiting state and resynchronizes it with the Interrupt Service Routine.<br>
					The thread will never get out of its waiting state, will exhaust almost all the available RAM and will continue to use the CPU intensively, causing a DoS condition on the system.
				</h3>
			</p>
		</div>
		
		<img src="media/thread_infinite_waiting_state.gif" alt="" title="The thread is in an infinite waiting state">
		
		<div>
			<p>
				<h3>
					While the DoS problem is triggered by the representation of a very large number of grid lines within a limited space, I suppose it can be split into at least two sub-problems:<br>
					<ol>
						<li>
							The mere operation of drawing a grid line which, repeated many times (99 billion in the case of the exploit just described), could require a lot of RAM and time.
						</li>
						
						<li>
							All the operations necessary to be able to draw the grid lines in a limited space, including the calculation of the distance that must exist between one line and another.
						</li>
					</ol>
					
					I suppose that point 2 <u>could be</u> even more problematic because, as we've seen <a href="#the_vulnerability">here</a>, Excel is coded to draw the grid lines so that they're equidistant from each other. This means that by increasing their number in a limited space, their distance decreases very quickly, forcing Excel to perform calculations and operations with very small decimal numbers.<br>
					Let's continue to consider <a href="#the_vulnerability">the previous animation</a> in which Excel, due to its vulnerability, for each additional SVVA unit adds 10 grid lines (I don’t consider the first grid line to simplify calculations) to the already existing ones, and look at how their distance changes (knowing that they must be drawn equidistant from each other) as a function of the increase in units of the SVVA.<br>
					If we assume that the height <code>h</code> of the chart is 1, the thickness of the lines is negligible and we suppose to add the new lines between the first and last line to simplify calculations then, to draw <code>n</code> equidistant grid lines we must distance them by a distance <code>d</code> equal to <code>h&bsol;(n+1)</code> from each other.<br>
					Since in our case Excel adds 10 grid lines for each SVVA additional unit, we get the following values:<br>
					<br>
					<table border="2" align="center">
						<th style="color:orange">SVVA units</th>
						<th style="color:gold">Grid lines number (n)</th>
						<th style="color:lightblue">Grid lines distance (d)</th>
						
						<tr>
							<td style="color:orange">1</td>
							<td style="color:gold">10</td>
							<td style="color:lightblue">0.090909090</td>
						</tr>
						
						<tr>
							<td style="color:orange">10</td>
							<td style="color:gold">100</td>
							<td style="color:lightblue">0,009900990</td>
						</tr>
						
						<tr>
							<td style="color:orange">100</td>
							<td style="color:gold">1000</td>
							<td style="color:lightblue">0,000999000</td>
						</tr>
						
						<tr>
							<td style="color:orange">1000</td>
							<td style="color:gold">10 000</td>
							<td style="color:lightblue">0,000099990</td>
						</tr>
						
						<tr>
							<td style="color:orange">10 000</td>
							<td style="color:gold">100 000</td>
							<td style="color:lightblue">0,000009999</td>
						</tr>
						
						<tr>
							<td style="color:orange">100 000</td>
							<td style="color:gold">1 000 000</td>
							<td style="color:lightblue">0.000000999</td>
						</tr>
						
						<tr>
							<td style="color:orange">1 000 000</td>
							<td style="color:gold">10 000 000</td>
							<td style="color:lightblue">0.000000099</td>
						</tr>
						
						<tr>
							<td style="color:orange">...</td>
							<td style="color:gold">...</td>
							<td style="color:lightblue">...</td>
						</tr>
						
						<tr>
							<td style="color:orange">99 000 000</td>
							<td style="color:gold">990 000 000</td>
							<td style="color:lightblue">0,000000001</td>
						</tr>
					</table>
					<br>
					We can see how, by greatly increasing the number of grid lines, their distance will asymptotically converge to zero without ever reaching it, and a decimal overflow <u>could</u> occur in the decimal variable which stores their distance value (if it's stored as a mantissa and an exponent) because it could no longer be represented by the exponent portion of the decimal representation.<br>
					This <u>could</u> lead to some memory corruption issue or infinite loop... But this is just an assumption, and I didn't investigate it any further.
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_10"></a>
				<h2>Open questions &#10067;&#10067;</h2>
				<h3>
					Although the vulnerability and the way to exploit it are clear, there're still some questions to which it would be interesting to find the answer:
					
					<ol>
						<li>
							Is my above assumption (regarding the sub-problem 2) correct?<br>
							If not, what's the root cause that, during the grid lines representation, brings the system into a prolonged DoS condition? Thread deadlock &sol; starvation? Infinite loop? Memory corruption (Overflow &sol; Underflow &sol; Use After Free &sol; ...)?
						</li>
						
						<li>
							Assuming that the maximum value of the PVVA is set to 1, is there an exact number of horizontal grid lines (a sort of threshold) beyond which, regardless of PC hardware performance (CPU, RAM, ...), Excel will always end up in a DoS condition and will never be able to draw them all?<br>
							If so, what is it? And why?<br>
							If not, will the chart be drawn correctly? Is it just a matter of time, RAM and computing power?
						</li>
						
						<li>
							Aside from the DoS attack, can the vulnerability be exploited to perform other types of attacks such as Remote Code Execution or Information Disclosure? If yes, how?
						</li>
					</ol>
					
					If you have the answer to one (or more) of these questions and would like to share it with me and the readers of this write-up, write to me at <code>luca.barile.research@gmail.com</code>; I'll add your answer to this paragraph ASAP.
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_11"></a>
				<h2>How to fix the vulnerability &#128657;</h2>
				<h3>
					The vulnerable condition can be reached in the following two ways:
					
					<ol>
						<li>
							The user creates a chart in which the SVVA is visible, sets the maximum value of the PVVA and deletes it.
						</li>
						
						<li>
							An attacker reproduces the situation described in point 1 by directly modifying the <code>.xml</code> file related to the chart (<code>chart1.xml</code>) and creating a specially crafted <code>.xlsx</code> file, as shown <a href="#par_8">here</a>.
						</li>
					</ol>
					
					To prevent the achievement of the vulnerable condition I propose, respectively, the following fixes:
					
					<ol>
						<li>
							When the user deletes a chart axis in which the maximum value has been set, Excel must reset that value to the default value (<code>Auto</code>).
						</li>
						
						<li>
							When Excel parses the <code>.xml</code> file related to a generic chart, it must check that none of the chart's axes is not visible (<code>&lt;c:delete val=&quot;1&quot;&sol;&gt;</code>) <u>and</u> with a maximum value set (<code>&lt;c:max val=&quot;some_number&quot;&sol;&gt;</code>) <u>at the same time</u>.<br>
							If both conditions are true at the same time, Excel must do one of the following:
							
							<ul>
								<li>
									Treat the file as invalid, show an error to the user and close the file (the best option in my opinion).
								</li>
								
								<li>
									Fix and open the file.<br>
									To fix the file Excel must reset the maximum value of the axis to the default value (<code>Auto</code>). To do this, it must delete the <code>&lt;c:max val=&quot;some_number&quot;&sol;&gt;</code> tag from the <code>.xml</code> file (if Excel doesn't find that tag among the various tags that define the properties of an axis, it sets the maximum value of the axis to <code>Auto</code>).
								</li>
							</ul>

						</li>
					</ol>
					
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_12"></a>
				<h2>Vulnerability disclosure timeline &#128197;</h2>
				<h3>
					All dates are reported according to the Italian Time Zone.<br>
					<a href="https://www.microsoft.com/en-us/msrc/bounty" target="_blank" rel="noopener noreferrer">Here</a> you can find the Microsoft Bug Bounty Programs and check if your submission type is eligible for Microsoft Bounty Awards.<br>
					<a href="https://msrc.microsoft.com/create-report" target="_blank" rel="noopener noreferrer">Here</a> you can report your vulnerability opening a new case.<br>
					<a href="media/msrc_vulnerability_workflow.png" target="_blank" rel="noopener noreferrer">Here</a> you can see the possible case statuses and understand how long you have to wait (indicatively) for the patch release.
					
					<ul>
						<li>
							2022-11-14 - The ITS student turned in his buggy <code>.xlsx</code> file which, once opened, triggers the DoS condition on the system.
						</li>
						
						<li>
							2022-11-20 - I reproduced the DoS condition on my system without investigating it.
						</li>
						
						<li>
							2022-12-01 - I started researching the cause of the DoS.
						</li>
						
						<li>
							2022-12-08 - I found out the two chart parameters to set to generate the vulnerable condition.
						</li>
						
						<li>
							2022-12-08 - I discovered how to exploit the vulnerable condition and generated a specially crafted <code>.xlsx</code> file to exploit it.
						</li>
						
						<li>
							2022-12-14 - I did further analysis (through Process Monitor, Process Explorer and <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener noreferrer">Windows Debugger</a>) to understand in more detail the root cause of the vulnerability and DoS.
						</li>
						
						<li>
							2022-12-19 - I started writing the report for <a href="https://www.zerodayinitiative.com/" target="_blank" rel="noopener noreferrer">ZDI</a>.
						</li>						
						
						<li>
							2022-12-21 - I finished writing the report for ZDI.
						</li>
						
						<li>
							2022-12-22 - I reported the vulnerability to ZDI.
						</li>
						
						<li>
							2022-12-22 - ZDI told me that they're not interested in DoS vulnerabilities in applications such as Microsoft Excel.
						</li>
						
						<li>
							2022-12-23 - I opened a case (Submission Number: <code>VULN-082616</code>) to <a href="https://msrc.microsoft.com/" target="_blank" rel="noopener noreferrer">MSRC</a> to know if they're interested in a Microsoft Excel DoS vulnerability.<br>
							Case status: <code>New</code>
						</li>
						
						<li>
							2022-12-27 - MSRC asked me if I could provide detailed reproduction steps and a Proof-of-Concept (PoC), such as a video recording, crash report, screenshots, or relevant code examples.
						</li>
						
						<li>
							2022-12-27 - I sent them the requested data.
						</li>
						
						<li>
							2022-12-28 - MSRC has opened a case for the issue (MSRC Case Number <code>76656</code>) asking me to keep the details of this case confidential during their investigation.<br>
							Case status: <code>New</code> &#10142; <code>Review&sol;Repro</code>.
						</li>
						
						<li>
							2023-01-19 - MSRC confirmed the vulnerability I reported and told me that they'll continue their investigation and determine how to address this issue.<br>
							They also asked me to let them know if I had additional information that could aid their investigation, or if I had questions.
							<br>
							Case status: <code>Review&sol;Repro</code> &#10142; <code>Develop</code>.
						</li>
						
						<li>
							2023-01-19 - I sent them the additional information and asked them some technical questions.
						</li>
						
						<li>
							2023-01-20 - MSRC told me that the engineering team was working on a fix for the issue.
						</li>

						<li>
							2023-02-10 - I asked MSRC for an update.
						</li>
						
						<li>
							2023-02-10 - MSRC told me that the engineering team is steel working on a fix for this issue and, as soon as they will have some more information, they will update me.
						</li>
						
						<li>
							2023-03-02 - MSRC told me that they're planning to release the fix for the vulnerability I reported in an upcoming patch, and will update me once the fix has been released.<br>
							Case status: <code>Develop</code> &#10142; <code>Pre-Release</code>.
						</li>
						
						<li>
							2023-03-14 - Microsoft releases the fix for the vulnerability on March Patch Tuesdays.<br>
							Case status: <code>Pre-Release</code> &#10142; <code>Release</code>.
						</li>
						
						<li>
							2023-03-15 - Microsoft told me that the fix for this report has been released, I was acknowledged in <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-23396" target="_blank" rel="noopener noreferrer">CVE-2023-23396</a> and the case is now closed.<br>
							Case status: <code>Release</code> &#10142; <code>Complete</code>.
						</li>
						
						<li>
							2023-03-16 - I posted this article on my <a href="https://lucabarile.github.io/Blog/blog.html" target="_blank" rel="noopener noreferrer">blog</a> and the exploit on my GitHub <a href="https://github.com/LucaBarile/CVE-2023-23396" target="_blank" rel="noopener noreferrer">page</a>.
						</li>

					</ul>
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_13"></a>
				<h2>Patch analysis &#129657;&#128269;</h2>
				<h3>
					Microsoft released the following fixes on 2023-03-14:
					
					<ul>
						<li>
							<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB5002362" target="_blank" rel="noopener noreferrer">KB5002362</a> for Microsoft Office Web Apps Server 2013 Service Pack 1.
						</li>
						
						<li>
							<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB5002356" target="_blank" rel="noopener noreferrer">KB5002356</a> for Microsoft Office Online Server.
						</li>
					</ul>
					
					On 2023-03-23 I updated Microsoft Excel to the latest version (Microsoft Excel for Microsoft 365 MSO (Version 2208 Build 16.0.15601.20540) 64-bit) and tested the exploit again.<br>
					The <a href="https://github.com/LucaBarile/CVE-2023-23396/raw/main/Exploit.xlsx" target="_blank" rel="noopener noreferrer">exploit</a> also worked correctly in the updated version of Excel installed on my PC, so I notified Microsoft.<br>
					On 2023-04-05 Microsoft replied as follows:<br>
					&quot;<i>MSRC has investigated this issue and concluded that while your report is valid, this does not require immediate servicing, as the attack results in a local client denial of service. As no further action is required by the MSRC, I am closing this case.</i>&quot;<br>
					This means that, at the time of writing (2023-04-07), the server versions of Microsoft Office (Microsoft Office Web Apps Server 2013 Service Pack 1 and Microsoft Office Online Server) have been fixed (via KB5002362 and KB5002356, respectively) but, <u>the client version is still vulnerable, so the exploit results in a 0-day for it</u>.
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_14"></a>
				<h2>Conclusion</h2>
				<h3>
					<ul>
						<li>
							Sometimes vulnerabilities can be discovered without being sought.
						</li>
						
						<li>
							As you can see <a href="https://www.google.com/search?q=excel+file+parsing+vulnerability" target="_blank" rel="noopener noreferrer">here</a>, many Excel vulnerabilities have been found in the way Excel parses specially crafted <code>.xlsx</code> files, so analyzing Excel file parsing process could be a good starting point to discover new vulnerabilities.
						</li>
						
						<li>
							Even if the vulnerability you found doesn't exactly match the submission types eligible for Microsoft Bounty Awards, still open a new case to MSRC to ask if they are interested in it; they might accept it, as in my case.
						</li>
					</ul>
					
					PS<br>
					In the end, the student who unintentionally triggered the Excel vulnerability, passed the test, achieving a positive score both in the Excel assignment and in the global test evaluation &#9989;
					
				</h3>
			</p>
		</div>
		
		<div>
			<p>
				<a name="par_15"></a>
				<h2>References &#128279;</h2>
				<h3>
					The references that have been useful to me to write this article and the exploit code are already present, in the form of links, in the previous paragraphs you have read and that make up this article.<br>
					The vulnerability was also published on the following web pages:
					
					<ul>
						<li>
							National Vulnerability Database (<a href="https://nvd.nist.gov/vuln/detail/CVE-2023-23396" target="_blank" rel="noopener noreferrer">here</a>).
						</li>
						
						<li>
							Common Vulnerabilities and Exposures List (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23396" target="_blank" rel="noopener noreferrer">here</a>).
						</li>
						
						<li>
							Microsoft Vulnerabilities Page (<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-23396" target="_blank" rel="noopener noreferrer">here</a>).
						</li>
					</ul>
					
					I published my exploit <a href="https://github.com/LucaBarile/CVE-2023-23396/raw/main/Exploit.xlsx" target="_blank" rel="noopener noreferrer">here</a>.<br>
					
				</h3>
			</p>
		</div>
		
		<br>
		<hr>		
		<h3 align="center">
			<i>If you liked this article, what do you think about buying me a unicorn? <a href="https://www.buymeacoffee.com/LucaBarile">Yeees! I'll buy it for you!</a></i> &#129412;
		</h3>
		
	</body>
	
</html>