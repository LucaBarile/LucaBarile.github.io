<!DOCTYPE html>

<!-- https://www.amp-what.com/unicode/search/icon -->
<!-- Serif - Times - Times New Roman (default font) -->
<!-- <a href="" target="_blank" rel="noopener noreferrer">linkText</a> (open the link in a new tab and avoid tabnabbing) -->
<!-- <a name="anchorName"></a> | <a href="#anchorName">link name</a> (anchor) -->

<html lang="en">

	<head>
		
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="Wacom Driver Arbitrary File Write Overwrite Vulnerability">
		<meta name="keywords" content="CVE-2022-43293, AFW, AFO, Arbitrary File Write, Arbitrary File Overwrite, Vulnerability, Wacom, Wacom Driver, Wacom Driver 6.3.46-1, Driver, Bug, Exploit, Security, Cybersecurity, 0-day, zero-day, Graphics tablet, Wacom Intuos, Logical vulnerability, Process Monitor, dynamic analysis, Write-up, Denial of Service, Windows Denial of Service, Persistent Windows Denial of Service, cng.sys, Cryptography Next Generation, POC, Proof Of Concept, SYSTEM, NT AUTHORITY\SYSTEM, NT AUTHORITY, Disclosure, Responsible disclosure, Luca Barile, Fix, Patch, update.xml, wactemp, Temp, Wacom_Tablet.exe, Wacom update, Impersonation, Timeline, Wacom_Tablet, symbolic link, mount point, Link Following, Attack">
		<meta name="author" content="Luca Barile">
		
		<link rel="stylesheet" href="../postsStyle.css">
		
		<title>CVE-2022-43293</title>
    
	</head>

	<body bgcolor="black" text="DarkGray" link="lightblue" alink="gold" vlink="DarkRed">
	
		<h1>Wacom Driver Arbitrary File Write\Overwrite Vulnerability</h1>
		<h2 align="center" style="color:white">CVE-2022-43293 (0-day)</h2>
		
		<div>
			<p>
				<h2 align="center">Table of Contents &#128220;</h2>
				<h3>
					<table border="1" align="center">
						<tr>
							<td>
								<ol>
									<li><a href="#par1">Premise</a></li>
									<li><a href="#par2">How did I discover the vulnerability?</a></li>
									<li><a href="#par3">Analyzing the Wacom device plugging\unplugging</a></li>
									<li><a href="#par4">An Arbitrary File Write\Overwrite primitive</a></li>
									<li><a href="#par5">The Exploit</a></li>
									<li><a href="#par6">POC</a></li>
									<li><a href="#par7">Constraints & workarounds</a></li>
									<li><a href="#par8">Wacom USB device plugging\unplugging simulation</a></li>
									<li><a href="#par9">From Arbitrary File Write\Overwrite to Windows Denial of Service</a></li>
									<li><a href="#par10">Something more on cng.sys</a></li>
									<li><a href="#par11">How to fix the vulnerability</a></li>
									<li><a href="#par12">Vulnerability disclosure timeline</a></li>
									<li><a href="#par13">Final considerations</a></li>
								</ol>
							</td>
						</tr>
					</table>
				</h3>	
			</p>
			
			<p>
				<a name="par1"></a>
				<h2>Premise</h2>
				<h3>
					This article describes a vulnerability affecting Wacom Driver <a href="https://github.com/LucaBarile/ZDI-CAN-16857/tree/main/WacomTablet_6.3.46-1" target="_blank" rel="noopener noreferrer">6.3.46-1</a> and <a href="https://github.com/LucaBarile/ZDI-CAN-16318/tree/main/WacomTablet_6.3.45-1" target="_blank" rel="noopener noreferrer">6.3.45-1</a> for Windows (it probably affects older versions as well, but I haven't tested them), and a way by which this vulnerability can be exploited to get an arbitrary file write\overwrite primitive (<u>with no control over the content of the file written\overwritten</u>).<br>
					I suggest to read <a href="../CVE-2022-38604/index.html" target="_blank" rel="noopener noreferrer">this</a> article to better understand some points of what youâ€™re going to read.
				</h3>
			</p>
			
			<p>
				<a name="par2"></a>
				<h2>How did I discover the vulnerability?</h2>
				<h3>
					All the previous Wacom Driver vulnerabilities I discovered (<a href="../ZDI-CAN-16318/lpe/index.html" target="_blank" rel="noopener noreferrer">1.1</a>, <a href="../ZDI-CAN-16318/arb_r/index.html" target="_blank" rel="noopener noreferrer">1.2</a>, <a href="../ZDI-CAN-16318/arb_rw/index.html" target="_blank" rel="noopener noreferrer">1.3</a>, <a href="../ZDI-CAN-16857/index.html" target="_blank" rel="noopener noreferrer">2</a> and <a href="../CVE-2022-38604/index.html" target="_blank" rel="noopener noreferrer">3</a>), were mainly discovered through the dynamic analysis (except <a href="../ZDI-CAN-16318/lpe/index.html" target="_blank" rel="noopener noreferrer">1.1</a>, which also required static analysis) of the Wacom Driver components (eg <code>Wacom_Tablet.exe</code>, <code>Remove.exe</code>, <code>WTabletServicePro.exe</code>, ...).<br>
					I don't have any Wacom device but, one day, I got the chance to use one (<a href="https://www.wacom.com/en-us/products/pen-tablets/wacom-intuos" target="_blank" rel="noopener noreferrer">Wacom Intuos Small Graphic Tablet</a>).<br>
					Only when a Wacom device is connected to the PC some features of <a href="https://101.wacom.com/UserHelp/en/WDC.htm" target="_blank" rel="noopener noreferrer">WacomDesktopCenter.exe</a> are enabled, so I took this opportunity to understand what happens (through dynamic analysis) when these features are used and, consequently, to look for some possible vulnerabilities.<br>
					Unfortunately the analysis of all the unlocked features didn't get me anywhere because they're managed by <code>WacomDesktopCenter.exe</code>, which runs and performs its operations with the privileges of the current user.<br>
					Not knowing what else to analyze, as a last resort, I tried to understand what happens when a Wacom device is plugged\unplugged via USB, and I discovered an unexpected and pleasant surprise &#128579;
				</h3>
			</p>
			
			<p>
				<a name="par3"></a>
				<h2>Analyzing the Wacom device plugging\unplugging &#128269;</h2>
				<h3>
					Using <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon" target="_blank" rel="noopener noreferrer">Process Monitor</a> I discovered that, when a Wacom device is plugged\unplugged via USB to the PC, <code>%ProgramFiles%\Tablet\Wacom\Wacom_Tablet.exe</code> is triggered and runs under the context of <a href="https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account" target="_blank" rel="noopener noreferrer">SYSTEM</a>.<br>
					Once triggered it tries to download the <code>update.xml</code> file from a Wacom server (<a href="http://link.wacom.com/wdc/update.xml" target="_blank" rel="noopener noreferrer">http://link.wacom.com/wdc/update.xml</a>) and, if the file get downloaded properly, <code>Wacom_Tablet.exe</code> saves it, <u>without <a href="https://docs.microsoft.com/en-us/windows/win32/com/impersonation" target="_blank" rel="noopener noreferrer">impersonating</a> the current user</u>, into the <code>%windir%\Temp\wactemp</code> folder.<br>
					<br>
					<u>Here's the problem:</u> the <code>wactemp</code> folder isn't created during the Wacom Driver installation therefore, the first time a Wacom device will be plugged in, and <code>Wacom_Tablet.exe</code> will be able to download the <code>update.xml</code> file from the Wacom server, the <code>wactemp</code> folder will be created (and it will no longer be deleted because it will be used to store the updated versions of the <code>update.xml</code> file) and the downloaded <code>update.xml</code> file will be saved in it.<br>
					You can see the creation of the <code>wactemp</code> folder and the <code>update.xml</code> file in the following image, obtained by analyzing with Process Monitor <u>the first</u> Wacom device plugging event.
				</h3>
			</p>	
		</div>

		<img src="media/wactemp&update.jpg" alt="" title="The first Wacom device plugging">

		<div>
			<p>
				<h3>
					But what if we create a <code>%windir%\Temp\wactemp</code> <a href="https://en.wikipedia.org/wiki/NTFS_volume_mount_point" target="_blank" rel="noopener noreferrer">NTFS volume mount point</a> before that happens?<br>
					We can do it because the regular user has <a href="../ZDI-CAN-16318/lpe/index.html#par6" target="_blank" rel="noopener noreferrer">special access</a> to the <code>%windir%\Temp</code> folder...<br>
					<br>
					Notes:
					<ul>
						<li>
							<code>Wacom_Tablet.exe</code> creates the <code>wactemp</code> folder only once because it will no longer be deleted after the first creation.
						</li>
						
						<li>
							When <code>Wacom_Tablet.exe</code> saves the downloaded <code>update.xml</code> file into the <code>wactemp</code> folder, if an older version of the <code>update.xml</code> is already present, it will be overwritten by the new one.
						</li>
						
						<li>
							If the <code>%windir%\Temp\wactemp</code> mount point isn't created before <code>Wacom_Tablet.exe</code> creates the <code>%windir%\Temp\wactemp</code> folder, it will no longer be possible to create it, because the regular user cannot delete the folders\files stored in the <code>%windir%\Temp</code> folder.
						</li>
						
						<li>
							If the PC isn't connected to the Internet, or the <code>update.xml</code> file download process fails for some reason, the <code>wactemp</code> folder and the <code>update.xml</code> file will not be created.
						</li>
						
						<li>
							<code>Wacom_Tablet.exe</code> tries to repeat the <code>update.xml</code> file download and save procedure even during the Wacom device unplugging event.
						</li>
						
						<li>
							As the name itself says, the <code>update.xml</code> file is necessary to understand if an update of the Wacom Driver (or some of its components related to the Wacom device used by the user) is available, and if the update is supported by the current version of the operating system.<br>
							In case <code>update.xml</code> is no longer available on the <a href="http://link.wacom.com/wdc/update.xml" target="_blank" rel="noopener noreferrer">Wacom server</a> and you want to analyze it, I saved a copy <a href="https://github.com/LucaBarile/CVE-2022-43293/blob/main/Files/update.xml" target="_blank" rel="noopener noreferrer">here</a> (downloaded on 2022-08-27).
						</li>
						
						<li>
							I suppose <code>Wacom_Tablet.exe</code> repeats the <code>update.xml</code> file download and save procedure every time a Wacom device is plugged\unplugged to the PC because it wants to check if there are updates for <u>that particular device</u> and, the data of a Wacom device, is collected at the time of its plugging\unplugging.<br>
							An alternative could be to store only the data of the <u>new</u> connected Wacom devices and search for updates only once a day (or at regular time intervals), without depending on the connection of a device. Could it work? &#129300;
						</li>
					</ul>
				</h3>
			</p>
			
			<p>
				<a name="par4"></a>
				<h2>An Arbitrary File Write\Overwrite primitive &#128221;</h2>
				<h3>
					Probably, if you have read these four articles (<a href="../ZDI-CAN-16857/index.html" target="_blank" rel="noopener noreferrer">1</a>, <a href="../ZDI-CAN-16318/arb_r/index.html" target="_blank" rel="noopener noreferrer">2</a>, <a href="../ZDI-CAN-16318/arb_rw/index.html" target="_blank" rel="noopener noreferrer">3</a> and <a href="../CVE-2022-38604/index.html" target="_blank" rel="noopener noreferrer">4</a>), by now you will have understood that when the situation just described occurs, the <a href="https://cwe.mitre.org/data/definitions/59.html" target="_blank" rel="noopener noreferrer">link following attack</a> is the first thing that comes to mind and, even in this case, it can be applied in a similar way to what has been done <a href="../ZDI-CAN-16318/arb_rw/index.html#par4" target="_blank" rel="noopener noreferrer">here</a> and <a href="../ZDI-CAN-16318/arb_rw/index.html#par6" target="_blank" rel="noopener noreferrer">here</a>.<br>
					We can create a <code>%windir%\Temp\wactemp</code> <a href="https://en.wikipedia.org/wiki/NTFS_volume_mount_point" target="_blank" rel="noopener noreferrer">NTFS volume mount point</a> to <a href="https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html" target="_blank" rel="noopener noreferrer">\RPC Control</a> before <code>Wacom_Tablet.exe</code> creates the <code>%windir%\Temp\wactemp</code> folder.<br>
					Then we can create a <a href="https://en.wikipedia.org/wiki/Symbolic_link" target="_blank" rel="noopener noreferrer">Symbolic link</a> from <code>\RPC Control\update.xml</code> to a file we want to write\overwrite (in my POC I used <code>%windir%\win.ini</code>).<br>
					Now the workflow is quite simple: when the user plugs in a Wacom device, <code>Wacom_Tablet.exe</code> will be triggered, download the <code>update.xml</code> file from the Wacom server (if the PC is connected to the Internet), create the <code>wactemp</code> folder (if it hasn't already been created) and save the downloaded <code>update.xml</code> file in it.<br>
					However, since we've created the <code>%windir%\Temp\wactemp</code> mount point, when <code>Wacom_Tablet.exe</code> will try to save the <code>update.xml</code> file into <code>%windir%\Temp\wactemp</code>, it will consider our mount point as a valid <code>wactemp</code> folder and try to write the downloaded <code>update.xml</code> file in it.<br>
					Since <code>%windir%\Temp\wactemp</code> is a mount point to <code>\RPC Control</code>, <code>Wacom_Tablet.exe</code> will be redirected (reparsed) and will try to write <code>\RPC Control\update.xml</code>.<br>
					Since <code>\RPC Control\update.xml</code> is a symbolic link to our target file (eg <code>%windir%\win.ini</code>), <code>Wacom_Tablet.exe</code> will be redirected again, and will write\overwrite the target file (and it will succeed because it's running under the context of <code>SYSTEM</code>) with the content of the downloaded <code>update.xml</code>.<br>
					If the target file doesn't exist, <code>Wacom_Tablet.exe</code> will create it and write the content of the downloaded <code>update.xml</code> in it, otherwise it will overwrite the contents of the already existing file with the content of the downloaded <code>update.xml</code>.<br>
					In the following image you can see <code>Wacom_Tablet.exe</code> reparsed to the target file <u>after</u> creating the <code>wactemp</code> mountpoint and plugging, <u>for the first time</u>, a Wacom device.
				</h3>
			</p>
		</div>
		
			<img src="media/Wacom_Tablet.exe_reparsed.jpg" alt="" title="Wacom_Tablet.exe reparsed to %windir%\win.ini">
		
		<div>
			<p>
				<a name="par5"></a>
				<h2>The Exploit &#9760;&#65039;</h2>
				<h3>
					The exploit that I wrote is based on the aforementioned workflow and performs the following steps:
					
					<ol>
					
						<li>
							Ask the user which file he wants to write\overwrite (let's suppose <code>%windir%\win.ini</code>).
						</li>
						
						<li>
							Create the <code>%windir%\Temp\wactemp</code> mount point to <code>\RPC Control</code>.
						</li>
						
						<li>
							Create the <code>\RPC Control\update.xml</code> symbolic link to <code>%windir%\win.ini</code>.
						</li>
						
						<li>
							When the user plugs in a Wacom device, <code>Wacom_Tablet.exe</code> is triggered (and runs under the context of <code>SYSTEM</code>).
						</li>
						
						<li>
							<code>Wacom_Tablet.exe</code> will download the <code>update.xml</code> file from a Wacom server and try to save it into the <code>%windir%\Temp\wactemp</code> folder.
						</li>
						
						<li>
							Since <code>%windir%\Temp\wactemp</code> is a mount point to <code>\RPC Control</code>, <code>Wacom_Tablet.exe</code> will be redirected and will try to write <code>\RPC Control\update.xml</code>.
						</li>
						
						<li>
							Since <code>\RPC Control\update.xml</code> is a symbolic link to <code>%windir%\win.ini</code>, <code>Wacom_Tablet.exe</code> will be redirected again, and will overwrite <code>%windir%\win.ini</code> with the content of the downloaded <code>update.xml</code>.
						</li>
					
					</ol>
					
					<a href="https://github.com/LucaBarile/CVE-2022-43293/tree/main/Exploit/Exploit.bat" target="_blank" rel="noopener noreferrer">Here</a> you can find my exploit.<br>
					If your operating system is not installed on the C drive, modify the exploit by replacing <code>CreateMountPoint.exe "C:\Windows\Temp\wactemp" "\RPC Control"</code> with <code>CreateMountPoint.exe "%windir%\Temp\wactemp" "\RPC Control"</code>.<br>
					<br>
					<code>CreateMountPoint.exe</code> and <code>CreateSymlink.exe</code> are programs developed by <a href="https://twitter.com/tiraniddo" target="_blank" rel="noopener noreferrer">James Forshaw</a> and are downloadable from his <a href="https://github.com/googleprojectzero/symboliclink-testing-tools" target="_blank" rel="noopener noreferrer">symboliclink-testing-tools</a> repository, respectively <a href="https://github.com/googleprojectzero/symboliclink-testing-tools/tree/main/CreateMountPoint" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://github.com/googleprojectzero/symboliclink-testing-tools/tree/main/CreateSymlink" target="_blank" rel="noopener noreferrer">here</a>.
				</h3>
			</p>
			
			<p>
				<a name="par6"></a>
				<h2>POC &#127910;</h2>
				<h3>
					I've tested the exploit only on Wacom Driver 6.3.46-1 but, most likely, it also works for the previous versions (and I hope not on the future ones &#128580;).<br>
					The Wacom device I plugged in to trigger <code>Wacom_Tablet.exe</code> is Wacom Intuos Small Graphic Tablet, but any Wacom device should be fine.<br>
				</h3>
			</p>
			
		</div>
			
		<img src="media/POC.gif" alt="" title="Exploitation Proof Of Concept">
		
		<div>
			<p>
				<a name="par7"></a>
				<h2>Constraints &#38; workarounds &#9940;&#8618;&#65039;</h2>
				<h3>
					To successfully exploit the arbitrary file write vulnerability we must face the following constraints:
					<ol>
						<li>
							We must create the <code>%windir%\Temp\wactemp</code> mount point before <code>Wacom_Tablet.exe</code> creates the <code>%windir%\Temp\wactemp</code> folder (otherwise we'll not be able to create the mount point).
						</li>
						
						<li>
							The PC must be connected to the Internet (otherwise <code>Wacom_Tablet.exe</code> will not be able to download the <code>update.xml</code> file).
						</li>
						
						<li>
							We <del>must</del> have a Wacom device (otherwise we won't be able to trigger <code>Wacom_Tablet.exe</code>).
						</li>
						
					</ol>
					
					To face the previous constraints, I came up with the following workarounds:
					
					<ol>
						<li>
							We've two possibilities:
							<ol>
								<li>
									The system administrator installs the Wacom Driver and we've the possibility to log into our account before he connects a Wacom device.<br>
									In this case <code>Wacom_Tablet.exe</code> has never been triggered and, consequently, the <code>%windir%\Temp\wactemp</code> folder has not been created yet.
								</li>
								
								<li>
									We create the <code>%windir%\Temp\wactemp</code> mount point before the system administrator installs the Wacom Driver.<br>
									We don't know if the system administrator will install it but, if he does, we'll be able to exploit the vulnerability even if he will connect a Wacom device before we can log into our account.
								</li>
							</ol>
						</li>
						
						<li>
							If the PC can be connected to the Internet the problem doesn't arise, otherwise we've two possibilities:
							<ol>
								<li>
									If the PC can use a Wi-Fi or Bluetooth connection, we can use our mobile phone as an Internet hotspot.
								</li>
								
								<li>
									If the PC has no connections, we can use a <a href="https://en.wikipedia.org/wiki/Mobile_broadband_modem" target="_blank" rel="noopener noreferrer">mobile broadband modem</a> or, more simply, we can connect a <a href="https://en.wikipedia.org/wiki/Wireless_USB" target="_blank" rel="noopener noreferrer">wireless USB</a> (in this second case, we're in the same situation described in the previous point, so we can use our mobile phone as an Internet hotspot).
								</li>
							</ol>
						</li>
						
						<li>
							This last problem is quite difficult to solve (for me, of course &#128546;); in the next paragraph I propose the only possible workaround I found.
						</li>
					</ol>
				</h3>
			</p>
		
			<p>
				<a name="par8"></a>
				<h2>Wacom USB device plugging\unplugging simulation &#128268;</h2>
				<h3>
					Is it possible to trigger <code>Wacom_Tablet.exe</code> without plugging or unplugging a Wacom device?<br>
					I analyzed several executable files (which are installed during the installation of the Wacom Driver) through static analysis to look for some interesting parameters that could be used to trigger <code>Wacom_Tablet.exe</code>, forcing it to download the <code>update.xml</code> file, but I didn't find anything interesting.<br>
					I tried to emulate a Wacom device on Windows but, the only emulators I found were those of Wacom PenPartner tablet (already included in <a href="https://en.wikipedia.org/wiki/QEMU" target="_blank" rel="noopener noreferrer">QEMU</a>), and <a href="https://github.com/thenickdude/wacom-qemu" target="_blank" rel="noopener noreferrer">those</a> developed by <a href="https://www.nicksherlock.com/" target="_blank" rel="noopener noreferrer">Nicholas Sherlock</a> (for Wacom Bamboo and Wacom Intuos 5 graphics tablet), which can be added to <a href="https://www.qemu.org/" target="_blank" rel="noopener noreferrer">QEMU</a>.<br>
					Unfortunately all three emulators are designed to run on QEMU, and my goal is to emulate a Wacom device on Windows, not on a Windows virtual machine running within QEMU.<br>
					At this point, the only plausible way Iâ€™ve found to trigger <code>Wacom_Tablet.exe</code> without plugging or unplugging a Wacom device, is to simulate (through a software) the Wacom USB device plugging (or unplugging) event.<br>
					Searching the net I found out that other people also needed, for different reasons, to simulate the USB plugging event of a particular device (as you can read <a href="https://superuser.com/questions/1452768/record-usb-input-and-emulate-it-later" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://forum.arduino.cc/t/simulate-a-device-being-plugged-into-windows-10/609881/16" target="_blank" rel="noopener noreferrer">here</a>).<br>
					In <a href="https://forum.arduino.cc/t/simulate-a-device-being-plugged-into-windows-10/609881/16" target="_blank" rel="noopener noreferrer">this</a> forum <a href="https://forum.arduino.cc/u/zwieblum" target="_blank" rel="noopener noreferrer">zwieblum</a> proposes an interesting way to simulate the plugging event of a general USB device, which consists in taking a dump (the packets that are exchanged) of the initial USB device communication, and reproducing it when you want to simulate the USB device plugging.<br>
					To take a dump of the initial USB device communication on Windows, we can use the <a href="https://desowin.org/usbpcap/" target="_blank" rel="noopener noreferrer">USBPcap</a> feature on <a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener noreferrer">Wireshark</a> (read <a href="https://wiki.wireshark.org/CaptureSetup/USB#windows" target="_blank" rel="noopener noreferrer">this</a> article and watch <a href="https://www.youtube.com/watch?v=Hvh5tqsVjf0&ab_channel=SKSolutions" target="_blank" rel="noopener noreferrer">this</a> video for more details).<br>
					To replay the captured packets back using a software (without any physical device flashing or other ways that require a physical device) it's not that simple, but <a href="https://github.com/JohnDMcMaster/usbrply" target="_blank" rel="noopener noreferrer">usbrply</a> is the software that's right for us.<br>
					It has been developed by <a href="https://twitter.com/johndmcmaster" target="_blank" rel="noopener noreferrer">John Mcmaster</a>, and allows you to convert a <a href="https://www.solarwinds.com/resources/it-glossary/pcap" target="_blank" rel="noopener noreferrer">.pcap</a> file (captured USB packets) to Python or C code that replays the captured USB commands.<br>
					In our case we are interested in capturing only the first packets, which are exchanged in the first seconds in which the Wacom device is plugged-in and correctly recognized (or those exchanged at the moment of the device unplugging), to trigger <code>Wacom_Tablet.exe</code>.<br>
					I captured twice <a href="https://github.com/LucaBarile/CVE-2022-43293/tree/main/Files/Plugging" target="_blank" rel="noopener noreferrer">the packets exchanged upon plugging</a> and five times <a href="https://github.com/LucaBarile/CVE-2022-43293/tree/main/Files/Unplugging" target="_blank" rel="noopener noreferrer">those exchanged upon unplugging</a>.<br>
					I configured usbrply as indicated <a href="https://github.com/JohnDMcMaster/usbrply#sample-workflows" target="_blank" rel="noopener noreferrer">here</a> (with <code>VID = 0x056A</code> and <code>PID = 0x0376</code> (taken from the string <code>USB\VID_056A&amp;PID&#95;0376</code> (read <a href="https://github.com/LucaBarile/CVE-2022-43293/blob/main/Files/vendor_and_device_ID.txt" target="_blank" rel="noopener noreferrer">this</a> file to figure out how to get that string))) and tried to reproduce the captured packets back.<br>
					For some reason all the attempts to reproduce the captured packets back have failed, for both types of packages (those that should have simulated the device plugging and those that should have simulated its unplugging).<br>
					I reached out to Nicholas Sherlock to ask him for help and some possible solution but, at the moment, no solution has been found.<br>
					However, I think this is the right way to simulate a Wacom device plugging\unplugging event to trigger <code>Wacom_Tablet.exe</code> without connecting any real device but, at the moment, I don't have the time to understand where the catch is.<br>
					I'd like to go back to investigate this question in the future and, if in the meantime you find the catch (or an alternative solution), send me a mail at <i>luca.barile.research@gmail.com</i>; I'll update this paragraph by adding your solution &#128521;<br>
				</h3>
			</p>
		
			<p>
				<a name="par9"></a>
				<h2>From Arbitrary File Write\Overwrite to Windows Denial of Service &#129695;&#10060;</h2>
				<h3>
					Another idea would be to use our Arbitrary File Write\Overwrite primitive for a permanent Windows Denial of Service attack.<br>
					If we want to deny the user to use the Windows OS (preventing it from booting properly), we could think to delete a file (or more files) necessary for its booting, like I did <a href="../CVE-2022-38604/index.html#par8" target="_blank" rel="noopener noreferrer">here</a>.<br>
					Curiously though, searching a bit on the net I ended up on <a href="https://labs.redyops.com/index.php/2020/04/27/dos-via-arbitrary-folder-creation/" target="_blank" rel="noopener noreferrer">this</a> page, which made me discover a different way (to create the <code>%windir%\system32\cng.sys</code> file (or folder)) to prevent Windows from booting and bring up the famous <a href="https://en.wikipedia.org/wiki/Blue_screen_of_death" target="_blank" rel="noopener noreferrer">BSoD</a>.<br>
					This may seem quite counterintuitive because it seems much more reasonable to delete some files needed to start the operating system to prevent Windows from booting, rather than creating a file (or a folder), even empty... Yet, as you can see in the PoC below, this technique works properly!
				</h3>
			</p>
		</div>
			
		<img src="media/BSoD.gif" alt="" title="cng.sys (file or folder) causes the Windows BSoD">
			
		<div>
			<p>
				<h3>
					So, if we want to use the exploit shown in the <a href="#par6">previous POC</a> to get a persistent Windows Denial of Service, all we have to do is enter <code>%windir%\system32\cng.sys</code> when we're asked which file we want to overwrite.<br>
					Since <code>%windir%\system32\cng.sys</code> doesn't exist in standard Windows installations, it will be created and, the next time Windows starts, the BSoD will be displayed (and the auto-repair Windows procedure won't be able to fix the problem).
				</h3>
			</p>
			
			<p>
				<a name="par10"></a>
				<h2>Something more on cng.sys &#128272;</h2>
				<h3>
					What is <code>cng.sys</code>?<br>
					What is it for?<br>
					Why does its creation prevent Windows from booting?<br>
					From the <a href="https://en.wikipedia.org/wiki/.sys" target="_blank" rel="noopener noreferrer">.sys</a> filename extension we can deduce that it's a system file, so it probably contains device drivers or hardware configurations for the system.<br>
					<a href="https://docs.microsoft.com/en-us/windows/win32/seccng/about-cng" target="_blank" rel="noopener noreferrer">Here</a> Microsoft confirms that it's a driver and, in particular, it's the Cryptography Next Generation (CNG) kernel driver.<br>
					The CNG API is the successor of <a href="https://en.wikipedia.org/wiki/Microsoft_CryptoAPI" target="_blank" rel="noopener noreferrer">CryptoAPI</a> (which is now deprecated), and consists of <a href="https://docs.microsoft.com/en-us/windows/win32/seccng/cryptographic-primitives" target="_blank" rel="noopener noreferrer">several primitives</a> that provides a set of functions useful for basic cryptographic operations.<br>
					These cryptographic operations are used by many programs to protect the user's privacy and keep its data confidential.<br>
					When Windows is installed (in my case I'm referring to Windows 10, but this probably also applies to other Windows versions), the <code>cng.sys</code> file doesn't exist in the <code>%windir%\system32</code> folder, because it's installed into <code>%windir%\system32\drivers</code> folder, and only <a href="https://www.makeuseof.com/tag/what-is-trustedinstaller-and-why-does-it-keep-me-from-renaming-files/" target="_blank" rel="noopener noreferrer">TrustedInstaller</a> has full access on it.<br>
					Since, for the reasons just described, <code>cng.sys</code> is a very important Windows kernel driver, the operating system loads it from <code>%windir%\system32\drivers</code> at startup but, if another <code>cng.sys</code> file (or folder) exists in the <code>%windir%\system32</code> folder, Windows loads it as well!<br>
					If the <code>%windir%\system32\cng.sys</code> is a fake file (or a folder), the operating system crashes during its loading, bringing up the BSoD.<br>
					This probably happens because of a wrong file search order; Windows looks for the <code>cng.sys</code> file first in the <code>%windir%\system32</code> folder and then in the <code>%windir%\system32\drivers</code> (or it follows another order but, at some point, it tries to load the <code>%windir%\system32\cng.sys</code> file anyway).<br>
					I don't know why Windows doesn't load <code>cng.sys</code> only from the right folder. Can it be because in previous versions of Windows it was located in <code>%windir%\system32</code>, and then it was moved to <code>%windir%\system32\drivers</code> but the developers forgot to update its folders search order?<br>
					Probably other Windows drivers can be exploited to get a BSoD as well. Do you know another one? Send me a mail at <i>luca.barile.research@gmail.com</i>; I'll update this paragraph by adding a list of drivers affected by the same problem &#128203;<br>
					<br>
					PS<br>
					Just to stay on topic... Did you know that a Security Feature Bypass vulnerability was found in <code>cng.sys</code>?<br>
					Take a look at <a href="https://www.cvedetails.com/cve/CVE-2018-0902/" target="_blank" rel="noopener noreferrer">CVE-2018-0902</a> for more details.
				</h3>
			</p>
			
			<p>
				<a name="par11"></a>
				<h2>How to fix the vulnerability &#128657;</h2>
				<h3>
					There are several solutions:<br>
					<ul>
						<li>
							Create the <code>%windir%\Temp\wactemp</code> folder directly during the Wacom Driver installation process, so that the user can't create a mount point in its place.<br>
							With this solution the user could still create files inside the folder, which could interfere in some way with the Wacom Drivers activities, so I don't think this is the best solution.
						</li>
						
						<li>
							Force <code>Wacom_Tablet.exe</code> to impersonate the user while creating the <code>%windir%\Temp\wactemp\update.xml</code> file.<br>
							By doing this, the link following attack will fail because when <code>Wacom_Tablet.exe</code> will be redirected, it will only be able to write\overwrite files that the user can already write\overwrite on his own.
						</li>
						
						<li>
							Create the <code>wactemp</code> folder under <code>%ProgramFiles%\Tablet\Wacom\</code> (where the user doesn't have write access).
						</li>
						
						<li>
							Check that <code>%windir%\Temp\wactemp</code> isn't a symbolic link before creating the <code>update.xml</code> file in it.<br>
							With this solution we've the same problem described in the first point.
						</li>
						
						<li>
							Change the update process logic, checking for updates directly by querying a Wacom server, without downloading any files to a temporary folder.
						</li>
					</ul>
				</h3>
			</p>
		
			<p>
				<a name="par12"></a>
				<h2>Vulnerability disclosure timeline &#128197;</h2>
				<h3>
					First of all, I checked if the vendor has launched a bug bounty program but, unfortunately, Wacom Technology Corporation has none and the only page where you can report something (<a href="https://support.wacom.com/hc/en-us/requests/new" target="_blank" rel="noopener noreferrer">this</a>), doesn't speak explicitly of any acknowledgement (neither meritocratically nor economically).<br>
					At this point I followed the MITRE <a href="https://cve.mitre.org/cve/researcher_reservation_guidelines" target="_blank" rel="noopener noreferrer">researcher reservation guidelines</a> and, since Wacom Technology Corporation isn't on the <a href="https://www.cve.org/PartnerInformation/ListofPartners" target="_blank" rel="noopener noreferrer">CNAs partner list</a>, the only two remaining possibilities were to contact the CNA of Last Resort (<a href="https://cve.mitre.org/about/terminology.html#cna-lr" target="_blank" rel="noopener noreferrer">CNA-LR</a>) through the <a href="https://cveform.mitre.org/" target="_blank" rel="noopener noreferrer">CVE Request web form</a> or a <a href="https://cve.mitre.org/cve/researcher_reservation_guidelines#process#4" target="_blank" rel="noopener noreferrer">third-party coordinator CNAs</a> (read <a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/a-simple-guide-to-getting-cves-published/" target="_blank" rel="noopener noreferrer">this</a> interesting article for more information on how to get a CVE published).<br>
					Since the CNA of Last Resort, as the word itself says, is <u>the last resort</u> (&#127965;&#65039;), I looked for a third-party CNA in the CNAs list and decided to contact the <a href="https://www.zerodayinitiative.com/" target="_blank" rel="noopener noreferrer">Zero Day Initiative</a> CNA.<br>
					ZDI relieves you from the burden of tracking the bug with the vendor, <u>could</u> make a monetary offer to the researcher (CNA of Last Resort doesn't), follows a <a href="https://www.bugcrowd.com/resource/what-is-responsible-disclosure/" target="_blank" rel="noopener noreferrer">responsible vulnerability disclosure</a> policy and has a <a href="https://www.zerodayinitiative.com/about/benefits/" target="_blank" rel="noopener noreferrer">loyalty program</a> (CNA of Last Resort doesn't). You can learn more about their disclosure policy <a href="https://www.zerodayinitiative.com/advisories/disclosure_policy/" target="_blank" rel="noopener noreferrer">here</a>.
					
					<ul>
						<!-- Italy (Milano) GMT+1 | ZDI (??) GMT-6 | Milano is 7h ahead of ZDI-->
						<li>2022-07-30 (GMT+1) - I discovered the vulnerability.</li>
						<li>2022-08-27 (GMT-6) - I reported the vulnerability to ZDI (CASE OPENED).</li>
						<li>2022-08-29 (GMT-6) - ZDI assigned the case (CASE ASSIGNED).</li>
						<li>2022-09-30 (GMT+1) - I asked ZDI for an update.</li>
						<li>2022-09-30 (GMT+1) - ZDI replied that they're currently experiencing high case volumes so I can expect several weeks for reply.</li>
						<li>2022-10-04 (GMT-6) - ZDI investigated the case (CASE INVESTIGATED).</li>
						<li>2022-10-12 (GMT+1) - ZDI replied that they aren't interested in this vulnerability because it requires a Wacom device for testing (CASE CLOSED) &#129300;</li>
					</ul>
						
					At this point the only alternative left is the CNA of Last Resort (CNA-LR), so I decided to use the CVE Request web form to report the vulnerability.<br>
					
					<ul>
						<li>2022-10-12 (GMT+1) - I submitted the vulnerability to CNA-LR.</li>
						<li>2022-10-12 (GMT+1) - CNA-LR assigned the ID 1344351 to my request.</li>
						<li>2022-11-14 (GMT+1) - CNA-LR reserved the <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-43293" target="_blank" rel="noopener noreferrer">CVE-2022-43293</a> ID for my vulnerability.</li>
						<li>2022-12-15 (GMT+1) - I asked to CNA-LR for an update (no answare...).</li>
						<li>2023-01-22 (GMT+1) - I asked to CNA-LR again for an update (no answare...).</li>
						<li>2023-02-22 (GMT+1) - I asked to CNA-LR again for an update (no answare...).</li>
						<li>2023-04-07 (GMT+1) - I decided to make the <a href="https://github.com/LucaBarile/CVE-2022-43293/tree/main/Exploit/" target="_blank" rel="noopener noreferrer">exploit</a> for this vulnerability (and related report) public on my GitHub <a href="https://github.com/LucaBarile/CVE-2022-43293" target="_blank" rel="noopener noreferrer">page</a> and informed MITRE through CNA-LR.</li>
					</ul>
				</h3>
			</p>
		
			<p>
				<a name="par13"></a>
				<h2>Final considerations</h2>
				<h3>
					<u>The references</u> that have been useful to me to write this article and the exploit code are already present, in the form of links, in the previous paragraphs you have read and that make up this article.<br>
					<u>The conclusions</u> are very similar to those that I wrote in some of my previous articles (<a href="../ZDI-CAN-16318/lpe/index.html" target="_blank" rel="noopener noreferrer">1</a>, <a href="../ZDI-CAN-16318/arb_r/index.html" target="_blank" rel="noopener noreferrer">1.1</a>, <a href="../ZDI-CAN-16318/arb_rw/index.html" target="_blank" rel="noopener noreferrer">1.2</a> and <a href="../ZDI-CAN-16857/index.html" target="_blank" rel="noopener noreferrer">2</a>) and concern the logical vulnerabilities and the link following attack technique.<br>
					The vulnerability I described in this article is just another example of a logical vulnerability discovered through dynamic analysis using Process Monitor and, if you've read my previous articles related to logical vulnerabilities, I think that the paragraphs that might be most interesting for you are the following three: <a href="#par8">1</a>, <a href="#par9">2</a> and <a href="#par10">3</a>.<br>
					<u>In this particular scenario</u> a device is needed to trigger the vulnerability, and find a software technique that allows the exploit to simulate its interactions (at least those necessary to trigger the vulnerability (e.g. device plugging\unplugging)), would make its presence  unnecessary, and wouldn't require particular operations by the user during the exploit execution (he just has to enter the path of the file to write\overwrite).<br>
					<u>More generally</u>, all the exploits related to vulnerabilities that fall under this scenario would be device-independent and, therefore, more powerful. For this reason, I suggest you deepen this &quot;software technique&quot;, and I think <a href="#par8">this</a> is a good starting point.
				</h3>
			</p>
			
		</div>

		<br>
		
		<hr>
		
		<h3 align="center">
			<i>If you liked this article, what do you think about buying me a unicorn? <a href="https://www.buymeacoffee.com/LucaBarile" target="_blank" rel="noopener noreferrer">Yeees! I'll buy it for you!</a></i> &#129412;
		</h3>
		
	</body>
</html>